
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>testing: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">testing/allocs.go (100.0%)</option>
				
				<option value="file1">testing/benchmark.go (68.1%)</option>
				
				<option value="file2">testing/cover.go (57.9%)</option>
				
				<option value="file3">testing/example.go (11.1%)</option>
				
				<option value="file4">testing/match.go (97.1%)</option>
				
				<option value="file5">testing/run_example.go (0.0%)</option>
				
				<option value="file6">testing/testing.go (70.2%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Copyright 2013 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package testing

import (
        "runtime"
)

// AllocsPerRun returns the average number of allocations during calls to f.
// Although the return value has type float64, it will always be an integral value.
//
// To compute the number of allocations, the function will first be run once as
// a warm-up. The average number of allocations over the specified number of
// runs will then be measured and returned.
//
// AllocsPerRun sets GOMAXPROCS to 1 during its measurement and will restore
// it before returning.
func AllocsPerRun(runs int, f func()) (avg float64) <span class="cov8" title="1">{
        defer runtime.GOMAXPROCS(runtime.GOMAXPROCS(1))

        // Warm up the function
        f()

        // Measure the starting statistics
        var memstats runtime.MemStats
        runtime.ReadMemStats(&amp;memstats)
        mallocs := 0 - memstats.Mallocs

        // Run the function the specified number of times
        for i := 0; i &lt; runs; i++ </span><span class="cov8" title="1">{
                f()
        }</span>

        // Read the final statistics
        <span class="cov8" title="1">runtime.ReadMemStats(&amp;memstats)
        mallocs += memstats.Mallocs

        // Average the mallocs over the runs (not counting the warm-up).
        // We are forced to return a float64 because the API is silly, but do
        // the division as integers so we can ask if AllocsPerRun()==1
        // instead of AllocsPerRun()&lt;2.
        return float64(mallocs / uint64(runs))</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package testing

import (
        "flag"
        "fmt"
        "internal/race"
        "io"
        "math"
        "os"
        "runtime"
        "sort"
        "strconv"
        "strings"
        "sync"
        "sync/atomic"
        "time"
        "unicode"
)

func initBenchmarkFlags() <span class="cov8" title="1">{
        matchBenchmarks = flag.String("test.bench", "", "run only benchmarks matching `regexp`")
        benchmarkMemory = flag.Bool("test.benchmem", false, "print memory allocations for benchmarks")
        flag.Var(&amp;benchTime, "test.benchtime", "run each benchmark for duration `d`")
}</span>

var (
        matchBenchmarks *string
        benchmarkMemory *bool

        benchTime = benchTimeFlag{d: 1 * time.Second} // changed during test of testing package
)

type benchTimeFlag struct {
        d time.Duration
        n int
}

func (f *benchTimeFlag) String() string <span class="cov8" title="1">{
        if f.n &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Sprintf("%dx", f.n)
        }</span>
        <span class="cov8" title="1">return time.Duration(f.d).String()</span>
}

func (f *benchTimeFlag) Set(s string) error <span class="cov0" title="0">{
        if strings.HasSuffix(s, "x") </span><span class="cov0" title="0">{
                n, err := strconv.ParseInt(s[:len(s)-1], 10, 0)
                if err != nil || n &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid count")
                }</span>
                <span class="cov0" title="0">*f = benchTimeFlag{n: int(n)}
                return nil</span>
        }
        <span class="cov0" title="0">d, err := time.ParseDuration(s)
        if err != nil || d &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid duration")
        }</span>
        <span class="cov0" title="0">*f = benchTimeFlag{d: d}
        return nil</span>
}

// Global lock to ensure only one benchmark runs at a time.
var benchmarkLock sync.Mutex

// Used for every benchmark for measuring memory.
var memStats runtime.MemStats

// InternalBenchmark is an internal type but exported because it is cross-package;
// it is part of the implementation of the "go test" command.
type InternalBenchmark struct {
        Name string
        F    func(b *B)
}

// B is a type passed to Benchmark functions to manage benchmark
// timing and to specify the number of iterations to run.
//
// A benchmark ends when its Benchmark function returns or calls any of the methods
// FailNow, Fatal, Fatalf, SkipNow, Skip, or Skipf. Those methods must be called
// only from the goroutine running the Benchmark function.
// The other reporting methods, such as the variations of Log and Error,
// may be called simultaneously from multiple goroutines.
//
// Like in tests, benchmark logs are accumulated during execution
// and dumped to standard output when done. Unlike in tests, benchmark logs
// are always printed, so as not to hide output whose existence may be
// affecting benchmark results.
type B struct {
        common
        importPath       string // import path of the package containing the benchmark
        context          *benchContext
        N                int
        previousN        int           // number of iterations in the previous run
        previousDuration time.Duration // total duration of the previous run
        benchFunc        func(b *B)
        benchTime        benchTimeFlag
        bytes            int64
        missingBytes     bool // one of the subbenchmarks does not have bytes set.
        timerOn          bool
        showAllocResult  bool
        result           BenchmarkResult
        parallelism      int // RunParallel creates parallelism*GOMAXPROCS goroutines
        // The initial states of memStats.Mallocs and memStats.TotalAlloc.
        startAllocs uint64
        startBytes  uint64
        // The net total of this test after being run.
        netAllocs uint64
        netBytes  uint64
        // Extra metrics collected by ReportMetric.
        extra map[string]float64
}

// StartTimer starts timing a test. This function is called automatically
// before a benchmark starts, but it can also be used to resume timing after
// a call to StopTimer.
func (b *B) StartTimer() <span class="cov8" title="1">{
        if !b.timerOn </span><span class="cov8" title="1">{
                runtime.ReadMemStats(&amp;memStats)
                b.startAllocs = memStats.Mallocs
                b.startBytes = memStats.TotalAlloc
                b.start = time.Now()
                b.timerOn = true
        }</span>
}

// StopTimer stops timing a test. This can be used to pause the timer
// while performing complex initialization that you don't
// want to measure.
func (b *B) StopTimer() <span class="cov8" title="1">{
        if b.timerOn </span><span class="cov8" title="1">{
                b.duration += time.Since(b.start)
                runtime.ReadMemStats(&amp;memStats)
                b.netAllocs += memStats.Mallocs - b.startAllocs
                b.netBytes += memStats.TotalAlloc - b.startBytes
                b.timerOn = false
        }</span>
}

// ResetTimer zeroes the elapsed benchmark time and memory allocation counters
// and deletes user-reported metrics.
// It does not affect whether the timer is running.
func (b *B) ResetTimer() <span class="cov8" title="1">{
        if b.extra == nil </span><span class="cov8" title="1">{
                // Allocate the extra map before reading memory stats.
                // Pre-size it to make more allocation unlikely.
                b.extra = make(map[string]float64, 16)
        }</span> else<span class="cov8" title="1"> {
                for k := range b.extra </span><span class="cov8" title="1">{
                        delete(b.extra, k)
                }</span>
        }
        <span class="cov8" title="1">if b.timerOn </span><span class="cov0" title="0">{
                runtime.ReadMemStats(&amp;memStats)
                b.startAllocs = memStats.Mallocs
                b.startBytes = memStats.TotalAlloc
                b.start = time.Now()
        }</span>
        <span class="cov8" title="1">b.duration = 0
        b.netAllocs = 0
        b.netBytes = 0</span>
}

// SetBytes records the number of bytes processed in a single operation.
// If this is called, the benchmark will report ns/op and MB/s.
func (b *B) SetBytes(n int64) <span class="cov8" title="1">{ b.bytes = n }</span>

// ReportAllocs enables malloc statistics for this benchmark.
// It is equivalent to setting -test.benchmem, but it only affects the
// benchmark function that calls ReportAllocs.
func (b *B) ReportAllocs() <span class="cov8" title="1">{
        b.showAllocResult = true
}</span>

// runN runs a single benchmark for the specified number of iterations.
func (b *B) runN(n int) <span class="cov8" title="1">{
        benchmarkLock.Lock()
        defer benchmarkLock.Unlock()
        defer b.runCleanup(normalPanic)
        // Try to get a comparable environment for each run
        // by clearing garbage from previous runs.
        runtime.GC()
        b.raceErrors = -race.Errors()
        b.N = n
        b.parallelism = 1
        b.ResetTimer()
        b.StartTimer()
        b.benchFunc(b)
        b.StopTimer()
        b.previousN = n
        b.previousDuration = b.duration
        b.raceErrors += race.Errors()
        if b.raceErrors &gt; 0 </span><span class="cov0" title="0">{
                b.Errorf("race detected during execution of benchmark")
        }</span>
}

func min(x, y int64) int64 <span class="cov8" title="1">{
        if x &gt; y </span><span class="cov8" title="1">{
                return y
        }</span>
        <span class="cov8" title="1">return x</span>
}

func max(x, y int64) int64 <span class="cov8" title="1">{
        if x &lt; y </span><span class="cov0" title="0">{
                return y
        }</span>
        <span class="cov8" title="1">return x</span>
}

// run1 runs the first iteration of benchFunc. It reports whether more
// iterations of this benchmarks should be run.
func (b *B) run1() bool <span class="cov8" title="1">{
        if ctx := b.context; ctx != nil </span><span class="cov0" title="0">{
                // Extend maxLen, if needed.
                if n := len(b.name) + ctx.extLen + 1; n &gt; ctx.maxLen </span><span class="cov0" title="0">{
                        ctx.maxLen = n + 8 // Add additional slack to avoid too many jumps in size.
                }</span>
        }
        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                // Signal that we're done whether we return normally
                // or by FailNow's runtime.Goexit.
                defer func() </span><span class="cov8" title="1">{
                        b.signal &lt;- true
                }</span>()

                <span class="cov8" title="1">b.runN(1)</span>
        }()
        <span class="cov8" title="1">&lt;-b.signal
        if b.failed </span><span class="cov8" title="1">{
                fmt.Fprintf(b.w, "--- FAIL: %s\n%s", b.name, b.output)
                return false
        }</span>
        // Only print the output if we know we are not going to proceed.
        // Otherwise it is printed in processBench.
        <span class="cov8" title="1">if atomic.LoadInt32(&amp;b.hasSub) != 0 || b.finished </span><span class="cov8" title="1">{
                tag := "BENCH"
                if b.skipped </span><span class="cov8" title="1">{
                        tag = "SKIP"
                }</span>
                <span class="cov8" title="1">if b.chatty != nil &amp;&amp; (len(b.output) &gt; 0 || b.finished) </span><span class="cov8" title="1">{
                        b.trimOutput()
                        fmt.Fprintf(b.w, "--- %s: %s\n%s", tag, b.name, b.output)
                }</span>
                <span class="cov8" title="1">return false</span>
        }
        <span class="cov8" title="1">return true</span>
}

var labelsOnce sync.Once

// run executes the benchmark in a separate goroutine, including all of its
// subbenchmarks. b must not have subbenchmarks.
func (b *B) run() <span class="cov8" title="1">{
        labelsOnce.Do(func() </span><span class="cov8" title="1">{
                fmt.Fprintf(b.w, "goos: %s\n", runtime.GOOS)
                fmt.Fprintf(b.w, "goarch: %s\n", runtime.GOARCH)
                if b.importPath != "" </span><span class="cov0" title="0">{
                        fmt.Fprintf(b.w, "pkg: %s\n", b.importPath)
                }</span>
        })
        <span class="cov8" title="1">if b.context != nil </span><span class="cov0" title="0">{
                // Running go test --test.bench
                b.context.processBench(b) // Must call doBench.
        }</span> else<span class="cov8" title="1"> {
                // Running func Benchmark.
                b.doBench()
        }</span>
}

func (b *B) doBench() BenchmarkResult <span class="cov8" title="1">{
        go b.launch()
        &lt;-b.signal
        return b.result
}</span>

// launch launches the benchmark function. It gradually increases the number
// of benchmark iterations until the benchmark runs for the requested benchtime.
// launch is run by the doBench function as a separate goroutine.
// run1 must have been called on b.
func (b *B) launch() <span class="cov8" title="1">{
        // Signal that we're done whether we return normally
        // or by FailNow's runtime.Goexit.
        defer func() </span><span class="cov8" title="1">{
                b.signal &lt;- true
        }</span>()

        // Run the benchmark for at least the specified amount of time.
        <span class="cov8" title="1">if b.benchTime.n &gt; 0 </span><span class="cov0" title="0">{
                b.runN(b.benchTime.n)
        }</span> else<span class="cov8" title="1"> {
                d := b.benchTime.d
                for n := int64(1); !b.failed &amp;&amp; b.duration &lt; d &amp;&amp; n &lt; 1e9; </span><span class="cov8" title="1">{
                        last := n
                        // Predict required iterations.
                        goalns := d.Nanoseconds()
                        prevIters := int64(b.N)
                        prevns := b.duration.Nanoseconds()
                        if prevns &lt;= 0 </span><span class="cov0" title="0">{
                                // Round up, to avoid div by zero.
                                prevns = 1
                        }</span>
                        // Order of operations matters.
                        // For very fast benchmarks, prevIters ~= prevns.
                        // If you divide first, you get 0 or 1,
                        // which can hide an order of magnitude in execution time.
                        // So multiply first, then divide.
                        <span class="cov8" title="1">n = goalns * prevIters / prevns
                        // Run more iterations than we think we'll need (1.2x).
                        n += n / 5
                        // Don't grow too fast in case we had timing errors previously.
                        n = min(n, 100*last)
                        // Be sure to run at least one more than last time.
                        n = max(n, last+1)
                        // Don't run more than 1e9 times. (This also keeps n in int range on 32 bit platforms.)
                        n = min(n, 1e9)
                        b.runN(int(n))</span>
                }
        }
        <span class="cov8" title="1">b.result = BenchmarkResult{b.N, b.duration, b.bytes, b.netAllocs, b.netBytes, b.extra}</span>
}

// ReportMetric adds "n unit" to the reported benchmark results.
// If the metric is per-iteration, the caller should divide by b.N,
// and by convention units should end in "/op".
// ReportMetric overrides any previously reported value for the same unit.
// ReportMetric panics if unit is the empty string or if unit contains
// any whitespace.
// If unit is a unit normally reported by the benchmark framework itself
// (such as "allocs/op"), ReportMetric will override that metric.
// Setting "ns/op" to 0 will suppress that built-in metric.
func (b *B) ReportMetric(n float64, unit string) <span class="cov8" title="1">{
        if unit == "" </span><span class="cov0" title="0">{
                panic("metric unit must not be empty")</span>
        }
        <span class="cov8" title="1">if strings.IndexFunc(unit, unicode.IsSpace) &gt;= 0 </span><span class="cov0" title="0">{
                panic("metric unit must not contain whitespace")</span>
        }
        <span class="cov8" title="1">b.extra[unit] = n</span>
}

// BenchmarkResult contains the results of a benchmark run.
type BenchmarkResult struct {
        N         int           // The number of iterations.
        T         time.Duration // The total time taken.
        Bytes     int64         // Bytes processed in one iteration.
        MemAllocs uint64        // The total number of memory allocations.
        MemBytes  uint64        // The total number of bytes allocated.

        // Extra records additional metrics reported by ReportMetric.
        Extra map[string]float64
}

// NsPerOp returns the "ns/op" metric.
func (r BenchmarkResult) NsPerOp() int64 <span class="cov8" title="1">{
        if v, ok := r.Extra["ns/op"]; ok </span><span class="cov8" title="1">{
                return int64(v)
        }</span>
        <span class="cov8" title="1">if r.N &lt;= 0 </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">return r.T.Nanoseconds() / int64(r.N)</span>
}

// mbPerSec returns the "MB/s" metric.
func (r BenchmarkResult) mbPerSec() float64 <span class="cov8" title="1">{
        if v, ok := r.Extra["MB/s"]; ok </span><span class="cov0" title="0">{
                return v
        }</span>
        <span class="cov8" title="1">if r.Bytes &lt;= 0 || r.T &lt;= 0 || r.N &lt;= 0 </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov0" title="0">return (float64(r.Bytes) * float64(r.N) / 1e6) / r.T.Seconds()</span>
}

// AllocsPerOp returns the "allocs/op" metric,
// which is calculated as r.MemAllocs / r.N.
func (r BenchmarkResult) AllocsPerOp() int64 <span class="cov8" title="1">{
        if v, ok := r.Extra["allocs/op"]; ok </span><span class="cov0" title="0">{
                return int64(v)
        }</span>
        <span class="cov8" title="1">if r.N &lt;= 0 </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">return int64(r.MemAllocs) / int64(r.N)</span>
}

// AllocedBytesPerOp returns the "B/op" metric,
// which is calculated as r.MemBytes / r.N.
func (r BenchmarkResult) AllocedBytesPerOp() int64 <span class="cov8" title="1">{
        if v, ok := r.Extra["B/op"]; ok </span><span class="cov0" title="0">{
                return int64(v)
        }</span>
        <span class="cov8" title="1">if r.N &lt;= 0 </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">return int64(r.MemBytes) / int64(r.N)</span>
}

// String returns a summary of the benchmark results.
// It follows the benchmark result line format from
// https://golang.org/design/14313-benchmark-format, not including the
// benchmark name.
// Extra metrics override built-in metrics of the same name.
// String does not include allocs/op or B/op, since those are reported
// by MemString.
func (r BenchmarkResult) String() string <span class="cov8" title="1">{
        buf := new(strings.Builder)
        fmt.Fprintf(buf, "%8d", r.N)

        // Get ns/op as a float.
        ns, ok := r.Extra["ns/op"]
        if !ok </span><span class="cov8" title="1">{
                ns = float64(r.T.Nanoseconds()) / float64(r.N)
        }</span>
        <span class="cov8" title="1">if ns != 0 </span><span class="cov8" title="1">{
                buf.WriteByte('\t')
                prettyPrint(buf, ns, "ns/op")
        }</span>

        <span class="cov8" title="1">if mbs := r.mbPerSec(); mbs != 0 </span><span class="cov0" title="0">{
                fmt.Fprintf(buf, "\t%7.2f MB/s", mbs)
        }</span>

        // Print extra metrics that aren't represented in the standard
        // metrics.
        <span class="cov8" title="1">var extraKeys []string
        for k := range r.Extra </span><span class="cov8" title="1">{
                switch k </span>{
                case "ns/op", "MB/s", "B/op", "allocs/op":<span class="cov8" title="1">
                        // Built-in metrics reported elsewhere.
                        continue</span>
                }
                <span class="cov8" title="1">extraKeys = append(extraKeys, k)</span>
        }
        <span class="cov8" title="1">sort.Strings(extraKeys)
        for _, k := range extraKeys </span><span class="cov8" title="1">{
                buf.WriteByte('\t')
                prettyPrint(buf, r.Extra[k], k)
        }</span>
        <span class="cov8" title="1">return buf.String()</span>
}

func prettyPrint(w io.Writer, x float64, unit string) <span class="cov8" title="1">{
        // Print all numbers with 10 places before the decimal point
        // and small numbers with three sig figs.
        var format string
        switch y := math.Abs(x); </span>{
        case y == 0 || y &gt;= 99.95:<span class="cov8" title="1">
                format = "%10.0f %s"</span>
        case y &gt;= 9.995:<span class="cov8" title="1">
                format = "%12.1f %s"</span>
        case y &gt;= 0.9995:<span class="cov8" title="1">
                format = "%13.2f %s"</span>
        case y &gt;= 0.09995:<span class="cov8" title="1">
                format = "%14.3f %s"</span>
        case y &gt;= 0.009995:<span class="cov8" title="1">
                format = "%15.4f %s"</span>
        case y &gt;= 0.0009995:<span class="cov8" title="1">
                format = "%16.5f %s"</span>
        default:<span class="cov0" title="0">
                format = "%17.6f %s"</span>
        }
        <span class="cov8" title="1">fmt.Fprintf(w, format, x, unit)</span>
}

// MemString returns r.AllocedBytesPerOp and r.AllocsPerOp in the same format as 'go test'.
func (r BenchmarkResult) MemString() string <span class="cov0" title="0">{
        return fmt.Sprintf("%8d B/op\t%8d allocs/op",
                r.AllocedBytesPerOp(), r.AllocsPerOp())
}</span>

// benchmarkName returns full name of benchmark including procs suffix.
func benchmarkName(name string, n int) string <span class="cov0" title="0">{
        if n != 1 </span><span class="cov0" title="0">{
                return fmt.Sprintf("%s-%d", name, n)
        }</span>
        <span class="cov0" title="0">return name</span>
}

type benchContext struct {
        match *matcher

        maxLen int // The largest recorded benchmark name.
        extLen int // Maximum extension length.
}

// RunBenchmarks is an internal function but exported because it is cross-package;
// it is part of the implementation of the "go test" command.
func RunBenchmarks(matchString func(pat, str string) (bool, error), benchmarks []InternalBenchmark) <span class="cov0" title="0">{
        runBenchmarks("", matchString, benchmarks)
}</span>

func runBenchmarks(importPath string, matchString func(pat, str string) (bool, error), benchmarks []InternalBenchmark) bool <span class="cov8" title="1">{
        // If no flag was specified, don't run benchmarks.
        if len(*matchBenchmarks) == 0 </span><span class="cov8" title="1">{
                return true
        }</span>
        // Collect matching benchmarks and determine longest name.
        <span class="cov0" title="0">maxprocs := 1
        for _, procs := range cpuList </span><span class="cov0" title="0">{
                if procs &gt; maxprocs </span><span class="cov0" title="0">{
                        maxprocs = procs
                }</span>
        }
        <span class="cov0" title="0">ctx := &amp;benchContext{
                match:  newMatcher(matchString, *matchBenchmarks, "-test.bench"),
                extLen: len(benchmarkName("", maxprocs)),
        }
        var bs []InternalBenchmark
        for _, Benchmark := range benchmarks </span><span class="cov0" title="0">{
                if _, matched, _ := ctx.match.fullName(nil, Benchmark.Name); matched </span><span class="cov0" title="0">{
                        bs = append(bs, Benchmark)
                        benchName := benchmarkName(Benchmark.Name, maxprocs)
                        if l := len(benchName) + ctx.extLen + 1; l &gt; ctx.maxLen </span><span class="cov0" title="0">{
                                ctx.maxLen = l
                        }</span>
                }
        }
        <span class="cov0" title="0">main := &amp;B{
                common: common{
                        name:  "Main",
                        w:     os.Stdout,
                        bench: true,
                },
                importPath: importPath,
                benchFunc: func(b *B) </span><span class="cov0" title="0">{
                        for _, Benchmark := range bs </span><span class="cov0" title="0">{
                                b.Run(Benchmark.Name, Benchmark.F)
                        }</span>
                },
                benchTime: benchTime,
                context:   ctx,
        }
        <span class="cov0" title="0">if Verbose() </span><span class="cov0" title="0">{
                main.chatty = newChattyPrinter(main.w)
        }</span>
        <span class="cov0" title="0">main.runN(1)
        return !main.failed</span>
}

// processBench runs bench b for the configured CPU counts and prints the results.
func (ctx *benchContext) processBench(b *B) <span class="cov0" title="0">{
        for i, procs := range cpuList </span><span class="cov0" title="0">{
                for j := uint(0); j &lt; *count; j++ </span><span class="cov0" title="0">{
                        runtime.GOMAXPROCS(procs)
                        benchName := benchmarkName(b.name, procs)

                        // If it's chatty, we've already printed this information.
                        if b.chatty == nil </span><span class="cov0" title="0">{
                                fmt.Fprintf(b.w, "%-*s\t", ctx.maxLen, benchName)
                        }</span>
                        // Recompute the running time for all but the first iteration.
                        <span class="cov0" title="0">if i &gt; 0 || j &gt; 0 </span><span class="cov0" title="0">{
                                b = &amp;B{
                                        common: common{
                                                signal: make(chan bool),
                                                name:   b.name,
                                                w:      b.w,
                                                chatty: b.chatty,
                                                bench:  true,
                                        },
                                        benchFunc: b.benchFunc,
                                        benchTime: b.benchTime,
                                }
                                b.run1()
                        }</span>
                        <span class="cov0" title="0">r := b.doBench()
                        if b.failed </span><span class="cov0" title="0">{
                                // The output could be very long here, but probably isn't.
                                // We print it all, regardless, because we don't want to trim the reason
                                // the benchmark failed.
                                fmt.Fprintf(b.w, "--- FAIL: %s\n%s", benchName, b.output)
                                continue</span>
                        }
                        <span class="cov0" title="0">results := r.String()
                        if b.chatty != nil </span><span class="cov0" title="0">{
                                fmt.Fprintf(b.w, "%-*s\t", ctx.maxLen, benchName)
                        }</span>
                        <span class="cov0" title="0">if *benchmarkMemory || b.showAllocResult </span><span class="cov0" title="0">{
                                results += "\t" + r.MemString()
                        }</span>
                        <span class="cov0" title="0">fmt.Fprintln(b.w, results)
                        // Unlike with tests, we ignore the -chatty flag and always print output for
                        // benchmarks since the output generation time will skew the results.
                        if len(b.output) &gt; 0 </span><span class="cov0" title="0">{
                                b.trimOutput()
                                fmt.Fprintf(b.w, "--- BENCH: %s\n%s", benchName, b.output)
                        }</span>
                        <span class="cov0" title="0">if p := runtime.GOMAXPROCS(-1); p != procs </span><span class="cov0" title="0">{
                                fmt.Fprintf(os.Stderr, "testing: %s left GOMAXPROCS set to %d\n", benchName, p)
                        }</span>
                }
        }
}

// Run benchmarks f as a subbenchmark with the given name. It reports
// whether there were any failures.
//
// A subbenchmark is like any other benchmark. A benchmark that calls Run at
// least once will not be measured itself and will be called once with N=1.
func (b *B) Run(name string, f func(b *B)) bool <span class="cov8" title="1">{
        // Since b has subbenchmarks, we will no longer run it as a benchmark itself.
        // Release the lock and acquire it on exit to ensure locks stay paired.
        atomic.StoreInt32(&amp;b.hasSub, 1)
        benchmarkLock.Unlock()
        defer benchmarkLock.Lock()

        benchName, ok, partial := b.name, true, false
        if b.context != nil </span><span class="cov0" title="0">{
                benchName, ok, partial = b.context.match.fullName(&amp;b.common, name)
        }</span>
        <span class="cov8" title="1">if !ok </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov8" title="1">var pc [maxStackLen]uintptr
        n := runtime.Callers(2, pc[:])
        sub := &amp;B{
                common: common{
                        signal:  make(chan bool),
                        name:    benchName,
                        parent:  &amp;b.common,
                        level:   b.level + 1,
                        creator: pc[:n],
                        w:       b.w,
                        chatty:  b.chatty,
                        bench:   true,
                },
                importPath: b.importPath,
                benchFunc:  f,
                benchTime:  b.benchTime,
                context:    b.context,
        }
        if partial </span><span class="cov0" title="0">{
                // Partial name match, like -bench=X/Y matching BenchmarkX.
                // Only process sub-benchmarks, if any.
                atomic.StoreInt32(&amp;sub.hasSub, 1)
        }</span>

        <span class="cov8" title="1">if b.chatty != nil </span><span class="cov8" title="1">{
                labelsOnce.Do(func() </span><span class="cov0" title="0">{
                        fmt.Printf("goos: %s\n", runtime.GOOS)
                        fmt.Printf("goarch: %s\n", runtime.GOARCH)
                        if b.importPath != "" </span><span class="cov0" title="0">{
                                fmt.Printf("pkg: %s\n", b.importPath)
                        }</span>
                })

                <span class="cov8" title="1">fmt.Println(benchName)</span>
        }

        <span class="cov8" title="1">if sub.run1() </span><span class="cov8" title="1">{
                sub.run()
        }</span>
        <span class="cov8" title="1">b.add(sub.result)
        return !sub.failed</span>
}

// add simulates running benchmarks in sequence in a single iteration. It is
// used to give some meaningful results in case func Benchmark is used in
// combination with Run.
func (b *B) add(other BenchmarkResult) <span class="cov8" title="1">{
        r := &amp;b.result
        // The aggregated BenchmarkResults resemble running all subbenchmarks as
        // in sequence in a single benchmark.
        r.N = 1
        r.T += time.Duration(other.NsPerOp())
        if other.Bytes == 0 </span><span class="cov8" title="1">{
                // Summing Bytes is meaningless in aggregate if not all subbenchmarks
                // set it.
                b.missingBytes = true
                r.Bytes = 0
        }</span>
        <span class="cov8" title="1">if !b.missingBytes </span><span class="cov8" title="1">{
                r.Bytes += other.Bytes
        }</span>
        <span class="cov8" title="1">r.MemAllocs += uint64(other.AllocsPerOp())
        r.MemBytes += uint64(other.AllocedBytesPerOp())</span>
}

// trimOutput shortens the output from a benchmark, which can be very long.
func (b *B) trimOutput() <span class="cov8" title="1">{
        // The output is likely to appear multiple times because the benchmark
        // is run multiple times, but at least it will be seen. This is not a big deal
        // because benchmarks rarely print, but just in case, we trim it if it's too long.
        const maxNewlines = 10
        for nlCount, j := 0, 0; j &lt; len(b.output); j++ </span><span class="cov0" title="0">{
                if b.output[j] == '\n' </span><span class="cov0" title="0">{
                        nlCount++
                        if nlCount &gt;= maxNewlines </span><span class="cov0" title="0">{
                                b.output = append(b.output[:j], "\n\t... [output truncated]\n"...)
                                break</span>
                        }
                }
        }
}

// A PB is used by RunParallel for running parallel benchmarks.
type PB struct {
        globalN *uint64 // shared between all worker goroutines iteration counter
        grain   uint64  // acquire that many iterations from globalN at once
        cache   uint64  // local cache of acquired iterations
        bN      uint64  // total number of iterations to execute (b.N)
}

// Next reports whether there are more iterations to execute.
func (pb *PB) Next() bool <span class="cov8" title="1">{
        if pb.cache == 0 </span><span class="cov8" title="1">{
                n := atomic.AddUint64(pb.globalN, pb.grain)
                if n &lt;= pb.bN </span><span class="cov8" title="1">{
                        pb.cache = pb.grain
                }</span> else<span class="cov8" title="1"> if n &lt; pb.bN+pb.grain </span><span class="cov8" title="1">{
                        pb.cache = pb.bN + pb.grain - n
                }</span> else<span class="cov8" title="1"> {
                        return false
                }</span>
        }
        <span class="cov8" title="1">pb.cache--
        return true</span>
}

// RunParallel runs a benchmark in parallel.
// It creates multiple goroutines and distributes b.N iterations among them.
// The number of goroutines defaults to GOMAXPROCS. To increase parallelism for
// non-CPU-bound benchmarks, call SetParallelism before RunParallel.
// RunParallel is usually used with the go test -cpu flag.
//
// The body function will be run in each goroutine. It should set up any
// goroutine-local state and then iterate until pb.Next returns false.
// It should not use the StartTimer, StopTimer, or ResetTimer functions,
// because they have global effect. It should also not call Run.
func (b *B) RunParallel(body func(*PB)) <span class="cov8" title="1">{
        if b.N == 0 </span><span class="cov0" title="0">{
                return // Nothing to do when probing.
        }</span>
        // Calculate grain size as number of iterations that take ~100µs.
        // 100µs is enough to amortize the overhead and provide sufficient
        // dynamic load balancing.
        <span class="cov8" title="1">grain := uint64(0)
        if b.previousN &gt; 0 &amp;&amp; b.previousDuration &gt; 0 </span><span class="cov8" title="1">{
                grain = 1e5 * uint64(b.previousN) / uint64(b.previousDuration)
        }</span>
        <span class="cov8" title="1">if grain &lt; 1 </span><span class="cov8" title="1">{
                grain = 1
        }</span>
        // We expect the inner loop and function call to take at least 10ns,
        // so do not do more than 100µs/10ns=1e4 iterations.
        <span class="cov8" title="1">if grain &gt; 1e4 </span><span class="cov0" title="0">{
                grain = 1e4
        }</span>

        <span class="cov8" title="1">n := uint64(0)
        numProcs := b.parallelism * runtime.GOMAXPROCS(0)
        var wg sync.WaitGroup
        wg.Add(numProcs)
        for p := 0; p &lt; numProcs; p++ </span><span class="cov8" title="1">{
                go func() </span><span class="cov8" title="1">{
                        defer wg.Done()
                        pb := &amp;PB{
                                globalN: &amp;n,
                                grain:   grain,
                                bN:      uint64(b.N),
                        }
                        body(pb)
                }</span>()
        }
        <span class="cov8" title="1">wg.Wait()
        if n &lt;= uint64(b.N) &amp;&amp; !b.Failed() </span><span class="cov0" title="0">{
                b.Fatal("RunParallel: body exited without pb.Next() == false")
        }</span>
}

// SetParallelism sets the number of goroutines used by RunParallel to p*GOMAXPROCS.
// There is usually no need to call SetParallelism for CPU-bound benchmarks.
// If p is less than 1, this call will have no effect.
func (b *B) SetParallelism(p int) <span class="cov8" title="1">{
        if p &gt;= 1 </span><span class="cov8" title="1">{
                b.parallelism = p
        }</span>
}

// Benchmark benchmarks a single function. It is useful for creating
// custom benchmarks that do not use the "go test" command.
//
// If f depends on testing flags, then Init must be used to register
// those flags before calling Benchmark and before calling flag.Parse.
//
// If f calls Run, the result will be an estimate of running all its
// subbenchmarks that don't call Run in sequence in a single benchmark.
func Benchmark(f func(b *B)) BenchmarkResult <span class="cov8" title="1">{
        b := &amp;B{
                common: common{
                        signal: make(chan bool),
                        w:      discard{},
                },
                benchFunc: f,
                benchTime: benchTime,
        }
        if b.run1() </span><span class="cov8" title="1">{
                b.run()
        }</span>
        <span class="cov8" title="1">return b.result</span>
}

type discard struct{}

func (discard) Write(b []byte) (n int, err error) <span class="cov8" title="1">{ return len(b), nil }</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">// Copyright 2013 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Support for test coverage.

package testing

import (
        "fmt"
        "os"
        "sync/atomic"
)

// CoverBlock records the coverage data for a single basic block.
// The fields are 1-indexed, as in an editor: The opening line of
// the file is number 1, for example. Columns are measured
// in bytes.
// NOTE: This struct is internal to the testing infrastructure and may change.
// It is not covered (yet) by the Go 1 compatibility guidelines.
type CoverBlock struct {
        Line0 uint32 // Line number for block start.
        Col0  uint16 // Column number for block start.
        Line1 uint32 // Line number for block end.
        Col1  uint16 // Column number for block end.
        Stmts uint16 // Number of statements included in this block.
}

var cover Cover

// Cover records information about test coverage checking.
// NOTE: This struct is internal to the testing infrastructure and may change.
// It is not covered (yet) by the Go 1 compatibility guidelines.
type Cover struct {
        Mode            string
        Counters        map[string][]uint32
        Blocks          map[string][]CoverBlock
        CoveredPackages string
}

// Coverage reports the current code coverage as a fraction in the range [0, 1].
// If coverage is not enabled, Coverage returns 0.
//
// When running a large set of sequential test cases, checking Coverage after each one
// can be useful for identifying which test cases exercise new code paths.
// It is not a replacement for the reports generated by 'go test -cover' and
// 'go tool cover'.
func Coverage() float64 <span class="cov0" title="0">{
        var n, d int64
        for _, counters := range cover.Counters </span><span class="cov0" title="0">{
                for i := range counters </span><span class="cov0" title="0">{
                        if atomic.LoadUint32(&amp;counters[i]) &gt; 0 </span><span class="cov0" title="0">{
                                n++
                        }</span>
                        <span class="cov0" title="0">d++</span>
                }
        }
        <span class="cov0" title="0">if d == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">return float64(n) / float64(d)</span>
}

// RegisterCover records the coverage data accumulators for the tests.
// NOTE: This function is internal to the testing infrastructure and may change.
// It is not covered (yet) by the Go 1 compatibility guidelines.
func RegisterCover(c Cover) <span class="cov8" title="1">{
        cover = c
}</span>

// mustBeNil checks the error and, if present, reports it and exits.
func mustBeNil(err error) <span class="cov8" title="1">{
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "testing: %s\n", err)
                os.Exit(2)
        }</span>
}

// coverReport reports the coverage percentage and writes a coverage profile if requested.
func coverReport() <span class="cov8" title="1">{
        var f *os.File
        var err error
        if *coverProfile != "" </span><span class="cov8" title="1">{
                f, err = os.Create(toOutputDir(*coverProfile))
                mustBeNil(err)
                fmt.Fprintf(f, "mode: %s\n", cover.Mode)
                defer func() </span><span class="cov0" title="0">{ mustBeNil(f.Close()) }</span>()
        }

        <span class="cov8" title="1">var active, total int64
        var count uint32
        for name, counts := range cover.Counters </span><span class="cov8" title="1">{
                blocks := cover.Blocks[name]
                for i := range counts </span><span class="cov8" title="1">{
                        stmts := int64(blocks[i].Stmts)
                        total += stmts
                        count = atomic.LoadUint32(&amp;counts[i]) // For -mode=atomic.
                        if count &gt; 0 </span><span class="cov8" title="1">{
                                active += stmts
                        }</span>
                        <span class="cov8" title="1">if f != nil </span><span class="cov8" title="1">{
                                _, err := fmt.Fprintf(f, "%s:%d.%d,%d.%d %d %d\n", name,
                                        blocks[i].Line0, blocks[i].Col0,
                                        blocks[i].Line1, blocks[i].Col1,
                                        stmts,
                                        count)
                                mustBeNil(err)
                        }</span>
                }
        }
        <span class="cov0" title="0">if total == 0 </span><span class="cov0" title="0">{
                fmt.Println("coverage: [no statements]")
                return
        }</span>
        <span class="cov0" title="0">fmt.Printf("coverage: %.1f%% of statements%s\n", 100*float64(active)/float64(total), cover.CoveredPackages)</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package testing

import (
        "fmt"
        "os"
        "sort"
        "strings"
        "time"
)

type InternalExample struct {
        Name      string
        F         func()
        Output    string
        Unordered bool
}

// RunExamples is an internal function but exported because it is cross-package;
// it is part of the implementation of the "go test" command.
func RunExamples(matchString func(pat, str string) (bool, error), examples []InternalExample) (ok bool) <span class="cov0" title="0">{
        _, ok = runExamples(matchString, examples)
        return ok
}</span>

func runExamples(matchString func(pat, str string) (bool, error), examples []InternalExample) (ran, ok bool) <span class="cov8" title="1">{
        ok = true

        var eg InternalExample

        for _, eg = range examples </span><span class="cov0" title="0">{
                matched, err := matchString(*match, eg.Name)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "testing: invalid regexp for -test.run: %s\n", err)
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">if !matched </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">ran = true
                if !runExample(eg) </span><span class="cov0" title="0">{
                        ok = false
                }</span>
        }

        <span class="cov8" title="1">return ran, ok</span>
}

func sortLines(output string) string <span class="cov0" title="0">{
        lines := strings.Split(output, "\n")
        sort.Strings(lines)
        return strings.Join(lines, "\n")
}</span>

// processRunResult computes a summary and status of the result of running an example test.
// stdout is the captured output from stdout of the test.
// recovered is the result of invoking recover after running the test, in case it panicked.
//
// If stdout doesn't match the expected output or if recovered is non-nil, it'll print the cause of failure to stdout.
// If the test is chatty/verbose, it'll print a success message to stdout.
// If recovered is non-nil, it'll panic with that value.
func (eg *InternalExample) processRunResult(stdout string, timeSpent time.Duration, recovered interface{}) (passed bool) <span class="cov0" title="0">{
        passed = true

        dstr := fmtDuration(timeSpent)
        var fail string
        got := strings.TrimSpace(stdout)
        want := strings.TrimSpace(eg.Output)
        if eg.Unordered </span><span class="cov0" title="0">{
                if sortLines(got) != sortLines(want) &amp;&amp; recovered == nil </span><span class="cov0" title="0">{
                        fail = fmt.Sprintf("got:\n%s\nwant (unordered):\n%s\n", stdout, eg.Output)
                }</span>
        } else<span class="cov0" title="0"> {
                if got != want &amp;&amp; recovered == nil </span><span class="cov0" title="0">{
                        fail = fmt.Sprintf("got:\n%s\nwant:\n%s\n", got, want)
                }</span>
        }
        <span class="cov0" title="0">if fail != "" || recovered != nil </span><span class="cov0" title="0">{
                fmt.Printf("--- FAIL: %s (%s)\n%s", eg.Name, dstr, fail)
                passed = false
        }</span> else<span class="cov0" title="0"> if *chatty </span><span class="cov0" title="0">{
                fmt.Printf("--- PASS: %s (%s)\n", eg.Name, dstr)
        }</span>
        <span class="cov0" title="0">if recovered != nil </span><span class="cov0" title="0">{
                // Propagate the previously recovered result, by panicking.
                panic(recovered)</span>
        }

        <span class="cov0" title="0">return</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">// Copyright 2015 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package testing

import (
        "fmt"
        "os"
        "strconv"
        "strings"
        "sync"
)

// matcher sanitizes, uniques, and filters names of subtests and subbenchmarks.
type matcher struct {
        filter    []string
        matchFunc func(pat, str string) (bool, error)

        mu       sync.Mutex
        subNames map[string]int64
}

// TODO: fix test_main to avoid race and improve caching, also allowing to
// eliminate this Mutex.
var matchMutex sync.Mutex

func newMatcher(matchString func(pat, str string) (bool, error), patterns, name string) *matcher <span class="cov8" title="1">{
        var filter []string
        if patterns != "" </span><span class="cov8" title="1">{
                filter = splitRegexp(patterns)
                for i, s := range filter </span><span class="cov8" title="1">{
                        filter[i] = rewrite(s)
                }</span>
                // Verify filters before doing any processing.
                <span class="cov8" title="1">for i, s := range filter </span><span class="cov8" title="1">{
                        if _, err := matchString(s, "non-empty"); err != nil </span><span class="cov0" title="0">{
                                fmt.Fprintf(os.Stderr, "testing: invalid regexp for element %d of %s (%q): %s\n", i, name, s, err)
                                os.Exit(1)
                        }</span>
                }
        }
        <span class="cov8" title="1">return &amp;matcher{
                filter:    filter,
                matchFunc: matchString,
                subNames:  map[string]int64{},
        }</span>
}

func (m *matcher) fullName(c *common, subname string) (name string, ok, partial bool) <span class="cov8" title="1">{
        name = subname

        m.mu.Lock()
        defer m.mu.Unlock()

        if c != nil &amp;&amp; c.level &gt; 0 </span><span class="cov8" title="1">{
                name = m.unique(c.name, rewrite(subname))
        }</span>

        <span class="cov8" title="1">matchMutex.Lock()
        defer matchMutex.Unlock()

        // We check the full array of paths each time to allow for the case that
        // a pattern contains a '/'.
        elem := strings.Split(name, "/")
        for i, s := range elem </span><span class="cov8" title="1">{
                if i &gt;= len(m.filter) </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">if ok, _ := m.matchFunc(m.filter[i], s); !ok </span><span class="cov8" title="1">{
                        return name, false, false
                }</span>
        }
        <span class="cov8" title="1">return name, true, len(elem) &lt; len(m.filter)</span>
}

func splitRegexp(s string) []string <span class="cov8" title="1">{
        a := make([]string, 0, strings.Count(s, "/"))
        cs := 0
        cp := 0
        for i := 0; i &lt; len(s); </span><span class="cov8" title="1">{
                switch s[i] </span>{
                case '[':<span class="cov8" title="1">
                        cs++</span>
                case ']':<span class="cov8" title="1">
                        if cs--; cs &lt; 0 </span><span class="cov8" title="1">{ // An unmatched ']' is legal.
                                cs = 0
                        }</span>
                case '(':<span class="cov8" title="1">
                        if cs == 0 </span><span class="cov8" title="1">{
                                cp++
                        }</span>
                case ')':<span class="cov8" title="1">
                        if cs == 0 </span><span class="cov8" title="1">{
                                cp--
                        }</span>
                case '\\':<span class="cov8" title="1">
                        i++</span>
                case '/':<span class="cov8" title="1">
                        if cs == 0 &amp;&amp; cp == 0 </span><span class="cov8" title="1">{
                                a = append(a, s[:i])
                                s = s[i+1:]
                                i = 0
                                continue</span>
                        }
                }
                <span class="cov8" title="1">i++</span>
        }
        <span class="cov8" title="1">return append(a, s)</span>
}

// unique creates a unique name for the given parent and subname by affixing it
// with one or more counts, if necessary.
func (m *matcher) unique(parent, subname string) string <span class="cov8" title="1">{
        name := fmt.Sprintf("%s/%s", parent, subname)
        empty := subname == ""
        for </span><span class="cov8" title="1">{
                next, exists := m.subNames[name]
                if !empty &amp;&amp; !exists </span><span class="cov8" title="1">{
                        m.subNames[name] = 1 // next count is 1
                        return name
                }</span>
                // Name was already used. We increment with the count and append a
                // string with the count.
                <span class="cov8" title="1">m.subNames[name] = next + 1

                // Add a count to guarantee uniqueness.
                name = fmt.Sprintf("%s#%02d", name, next)
                empty = false</span>
        }
}

// rewrite rewrites a subname to having only printable characters and no white
// space.
func rewrite(s string) string <span class="cov8" title="1">{
        b := []byte{}
        for _, r := range s </span><span class="cov8" title="1">{
                switch </span>{
                case isSpace(r):<span class="cov8" title="1">
                        b = append(b, '_')</span>
                case !strconv.IsPrint(r):<span class="cov8" title="1">
                        s := strconv.QuoteRune(r)
                        b = append(b, s[1:len(s)-1]...)</span>
                default:<span class="cov8" title="1">
                        b = append(b, string(r)...)</span>
                }
        }
        <span class="cov8" title="1">return string(b)</span>
}

func isSpace(r rune) bool <span class="cov8" title="1">{
        if r &lt; 0x2000 </span><span class="cov8" title="1">{
                switch r </span>{
                // Note: not the same as Unicode Z class.
                case '\t', '\n', '\v', '\f', '\r', ' ', 0x85, 0xA0, 0x1680:<span class="cov8" title="1">
                        return true</span>
                }
        } else<span class="cov8" title="1"> {
                if r &lt;= 0x200a </span><span class="cov8" title="1">{
                        return true
                }</span>
                <span class="cov8" title="1">switch r </span>{
                case 0x2028, 0x2029, 0x202f, 0x205f, 0x3000:<span class="cov8" title="1">
                        return true</span>
                }
        }
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// Copyright 2019 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build !js

// TODO(@musiol, @odeke-em): re-unify this entire file back into
// example.go when js/wasm gets an os.Pipe implementation
// and no longer needs this separation.

package testing

import (
        "fmt"
        "io"
        "os"
        "strings"
        "time"
)

func runExample(eg InternalExample) (ok bool) <span class="cov0" title="0">{
        if *chatty </span><span class="cov0" title="0">{
                fmt.Printf("=== RUN   %s\n", eg.Name)
        }</span>

        // Capture stdout.
        <span class="cov0" title="0">stdout := os.Stdout
        r, w, err := os.Pipe()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintln(os.Stderr, err)
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">os.Stdout = w
        outC := make(chan string)
        go func() </span><span class="cov0" title="0">{
                var buf strings.Builder
                _, err := io.Copy(&amp;buf, r)
                r.Close()
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "testing: copying pipe: %v\n", err)
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">outC &lt;- buf.String()</span>
        }()

        <span class="cov0" title="0">start := time.Now()

        // Clean up in a deferred call so we can recover if the example panics.
        defer func() </span><span class="cov0" title="0">{
                timeSpent := time.Since(start)

                // Close pipe, restore stdout, get output.
                w.Close()
                os.Stdout = stdout
                out := &lt;-outC

                err := recover()
                ok = eg.processRunResult(out, timeSpent, err)
        }</span>()

        // Run example.
        <span class="cov0" title="0">eg.F()
        return</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Package testing provides support for automated testing of Go packages.
// It is intended to be used in concert with the "go test" command, which automates
// execution of any function of the form
//     func TestXxx(*testing.T)
// where Xxx does not start with a lowercase letter. The function name
// serves to identify the test routine.
//
// Within these functions, use the Error, Fail or related methods to signal failure.
//
// To write a new test suite, create a file whose name ends _test.go that
// contains the TestXxx functions as described here. Put the file in the same
// package as the one being tested. The file will be excluded from regular
// package builds but will be included when the "go test" command is run.
// For more detail, run "go help test" and "go help testflag".
//
// A simple test function looks like this:
//
//     func TestAbs(t *testing.T) {
//         got := Abs(-1)
//         if got != 1 {
//             t.Errorf("Abs(-1) = %d; want 1", got)
//         }
//     }
//
// Benchmarks
//
// Functions of the form
//     func BenchmarkXxx(*testing.B)
// are considered benchmarks, and are executed by the "go test" command when
// its -bench flag is provided. Benchmarks are run sequentially.
//
// For a description of the testing flags, see
// https://golang.org/cmd/go/#hdr-Testing_flags
//
// A sample benchmark function looks like this:
//     func BenchmarkRandInt(b *testing.B) {
//         for i := 0; i &lt; b.N; i++ {
//             rand.Int()
//         }
//     }
//
// The benchmark function must run the target code b.N times.
// During benchmark execution, b.N is adjusted until the benchmark function lasts
// long enough to be timed reliably. The output
//     BenchmarkRandInt-8           68453040                17.8 ns/op
// means that the loop ran 68453040 times at a speed of 17.8 ns per loop.
//
// If a benchmark needs some expensive setup before running, the timer
// may be reset:
//
//     func BenchmarkBigLen(b *testing.B) {
//         big := NewBig()
//         b.ResetTimer()
//         for i := 0; i &lt; b.N; i++ {
//             big.Len()
//         }
//     }
//
// If a benchmark needs to test performance in a parallel setting, it may use
// the RunParallel helper function; such benchmarks are intended to be used with
// the go test -cpu flag:
//
//     func BenchmarkTemplateParallel(b *testing.B) {
//         templ := template.Must(template.New("test").Parse("Hello, {{.}}!"))
//         b.RunParallel(func(pb *testing.PB) {
//             var buf bytes.Buffer
//             for pb.Next() {
//                 buf.Reset()
//                 templ.Execute(&amp;buf, "World")
//             }
//         })
//     }
//
// Examples
//
// The package also runs and verifies example code. Example functions may
// include a concluding line comment that begins with "Output:" and is compared with
// the standard output of the function when the tests are run. (The comparison
// ignores leading and trailing space.) These are examples of an example:
//
//     func ExampleHello() {
//         fmt.Println("hello")
//         // Output: hello
//     }
//
//     func ExampleSalutations() {
//         fmt.Println("hello, and")
//         fmt.Println("goodbye")
//         // Output:
//         // hello, and
//         // goodbye
//     }
//
// The comment prefix "Unordered output:" is like "Output:", but matches any
// line order:
//
//     func ExamplePerm() {
//         for _, value := range Perm(5) {
//             fmt.Println(value)
//         }
//         // Unordered output: 4
//         // 2
//         // 1
//         // 3
//         // 0
//     }
//
// Example functions without output comments are compiled but not executed.
//
// The naming convention to declare examples for the package, a function F, a type T and
// method M on type T are:
//
//     func Example() { ... }
//     func ExampleF() { ... }
//     func ExampleT() { ... }
//     func ExampleT_M() { ... }
//
// Multiple example functions for a package/type/function/method may be provided by
// appending a distinct suffix to the name. The suffix must start with a
// lower-case letter.
//
//     func Example_suffix() { ... }
//     func ExampleF_suffix() { ... }
//     func ExampleT_suffix() { ... }
//     func ExampleT_M_suffix() { ... }
//
// The entire test file is presented as the example when it contains a single
// example function, at least one other function, type, variable, or constant
// declaration, and no test or benchmark functions.
//
// Skipping
//
// Tests or benchmarks may be skipped at run time with a call to
// the Skip method of *T or *B:
//
//     func TestTimeConsuming(t *testing.T) {
//         if testing.Short() {
//             t.Skip("skipping test in short mode.")
//         }
//         ...
//     }
//
// Subtests and Sub-benchmarks
//
// The Run methods of T and B allow defining subtests and sub-benchmarks,
// without having to define separate functions for each. This enables uses
// like table-driven benchmarks and creating hierarchical tests.
// It also provides a way to share common setup and tear-down code:
//
//     func TestFoo(t *testing.T) {
//         // &lt;setup code&gt;
//         t.Run("A=1", func(t *testing.T) { ... })
//         t.Run("A=2", func(t *testing.T) { ... })
//         t.Run("B=1", func(t *testing.T) { ... })
//         // &lt;tear-down code&gt;
//     }
//
// Each subtest and sub-benchmark has a unique name: the combination of the name
// of the top-level test and the sequence of names passed to Run, separated by
// slashes, with an optional trailing sequence number for disambiguation.
//
// The argument to the -run and -bench command-line flags is an unanchored regular
// expression that matches the test's name. For tests with multiple slash-separated
// elements, such as subtests, the argument is itself slash-separated, with
// expressions matching each name element in turn. Because it is unanchored, an
// empty expression matches any string.
// For example, using "matching" to mean "whose name contains":
//
//     go test -run ''      # Run all tests.
//     go test -run Foo     # Run top-level tests matching "Foo", such as "TestFooBar".
//     go test -run Foo/A=  # For top-level tests matching "Foo", run subtests matching "A=".
//     go test -run /A=1    # For all top-level tests, run subtests matching "A=1".
//
// Subtests can also be used to control parallelism. A parent test will only
// complete once all of its subtests complete. In this example, all tests are
// run in parallel with each other, and only with each other, regardless of
// other top-level tests that may be defined:
//
//     func TestGroupedParallel(t *testing.T) {
//         for _, tc := range tests {
//             tc := tc // capture range variable
//             t.Run(tc.Name, func(t *testing.T) {
//                 t.Parallel()
//                 ...
//             })
//         }
//     }
//
// The race detector kills the program if it exceeds 8192 concurrent goroutines,
// so use care when running parallel tests with the -race flag set.
//
// Run does not return until parallel subtests have completed, providing a way
// to clean up after a group of parallel tests:
//
//     func TestTeardownParallel(t *testing.T) {
//         // This Run will not return until the parallel tests finish.
//         t.Run("group", func(t *testing.T) {
//             t.Run("Test1", parallelTest1)
//             t.Run("Test2", parallelTest2)
//             t.Run("Test3", parallelTest3)
//         })
//         // &lt;tear-down code&gt;
//     }
//
// Main
//
// It is sometimes necessary for a test program to do extra setup or teardown
// before or after testing. It is also sometimes necessary for a test to control
// which code runs on the main thread. To support these and other cases,
// if a test file contains a function:
//
//        func TestMain(m *testing.M)
//
// then the generated test will call TestMain(m) instead of running the tests
// directly. TestMain runs in the main goroutine and can do whatever setup
// and teardown is necessary around a call to m.Run. m.Run will return an exit
// code that may be passed to os.Exit. If TestMain returns, the test wrapper
// will pass the result of m.Run to os.Exit itself.
//
// When TestMain is called, flag.Parse has not been run. If TestMain depends on
// command-line flags, including those of the testing package, it should call
// flag.Parse explicitly. Command line flags are always parsed by the time test
// or benchmark functions run.
//
// A simple implementation of TestMain is:
//
//        func TestMain(m *testing.M) {
//                // call flag.Parse() here if TestMain uses flags
//                os.Exit(m.Run())
//        }
//
package testing

import (
        "bytes"
        "errors"
        "flag"
        "fmt"
        "internal/race"
        "io"
        "io/ioutil"
        "os"
        "runtime"
        "runtime/debug"
        "runtime/trace"
        "strconv"
        "strings"
        "sync"
        "sync/atomic"
        "time"
)

var initRan bool

// Init registers testing flags. These flags are automatically registered by
// the "go test" command before running test functions, so Init is only needed
// when calling functions such as Benchmark without using "go test".
//
// Init has no effect if it was already called.
func Init() <span class="cov8" title="1">{
        if initRan </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">initRan = true
        // The short flag requests that tests run more quickly, but its functionality
        // is provided by test writers themselves. The testing package is just its
        // home. The all.bash installation script sets it to make installation more
        // efficient, but by default the flag is off so a plain "go test" will do a
        // full test of the package.
        short = flag.Bool("test.short", false, "run smaller test suite to save time")

        // The failfast flag requests that test execution stop after the first test failure.
        failFast = flag.Bool("test.failfast", false, "do not start new tests after the first test failure")

        // The directory in which to create profile files and the like. When run from
        // "go test", the binary always runs in the source directory for the package;
        // this flag lets "go test" tell the binary to write the files in the directory where
        // the "go test" command is run.
        outputDir = flag.String("test.outputdir", "", "write profiles to `dir`")
        // Report as tests are run; default is silent for success.
        chatty = flag.Bool("test.v", false, "verbose: print additional output")
        count = flag.Uint("test.count", 1, "run tests and benchmarks `n` times")
        coverProfile = flag.String("test.coverprofile", "", "write a coverage profile to `file`")
        matchList = flag.String("test.list", "", "list tests, examples, and benchmarks matching `regexp` then exit")
        match = flag.String("test.run", "", "run only tests and examples matching `regexp`")
        memProfile = flag.String("test.memprofile", "", "write an allocation profile to `file`")
        memProfileRate = flag.Int("test.memprofilerate", 0, "set memory allocation profiling `rate` (see runtime.MemProfileRate)")
        cpuProfile = flag.String("test.cpuprofile", "", "write a cpu profile to `file`")
        blockProfile = flag.String("test.blockprofile", "", "write a goroutine blocking profile to `file`")
        blockProfileRate = flag.Int("test.blockprofilerate", 1, "set blocking profile `rate` (see runtime.SetBlockProfileRate)")
        mutexProfile = flag.String("test.mutexprofile", "", "write a mutex contention profile to the named file after execution")
        mutexProfileFraction = flag.Int("test.mutexprofilefraction", 1, "if &gt;= 0, calls runtime.SetMutexProfileFraction()")
        traceFile = flag.String("test.trace", "", "write an execution trace to `file`")
        timeout = flag.Duration("test.timeout", 0, "panic test binary after duration `d` (default 0, timeout disabled)")
        cpuListStr = flag.String("test.cpu", "", "comma-separated `list` of cpu counts to run each test with")
        parallel = flag.Int("test.parallel", runtime.GOMAXPROCS(0), "run at most `n` tests in parallel")
        testlog = flag.String("test.testlogfile", "", "write test action log to `file` (for use only by cmd/go)")

        initBenchmarkFlags()</span>
}

var (
        // Flags, registered during Init.
        short                *bool
        failFast             *bool
        outputDir            *string
        chatty               *bool
        count                *uint
        coverProfile         *string
        matchList            *string
        match                *string
        memProfile           *string
        memProfileRate       *int
        cpuProfile           *string
        blockProfile         *string
        blockProfileRate     *int
        mutexProfile         *string
        mutexProfileFraction *int
        traceFile            *string
        timeout              *time.Duration
        cpuListStr           *string
        parallel             *int
        testlog              *string

        haveExamples bool // are there examples?

        cpuList     []int
        testlogFile *os.File

        numFailed uint32 // number of test failures
)

type chattyPrinter struct {
        w          io.Writer
        lastNameMu sync.Mutex // guards lastName
        lastName   string     // last printed test name in chatty mode
}

func newChattyPrinter(w io.Writer) *chattyPrinter <span class="cov8" title="1">{
        return &amp;chattyPrinter{w: w}
}</span>

// Updatef prints a message about the status of the named test to w.
//
// The formatted message must include the test name itself.
func (p *chattyPrinter) Updatef(testName, format string, args ...interface{}) <span class="cov8" title="1">{
        p.lastNameMu.Lock()
        defer p.lastNameMu.Unlock()

        // Since the message already implies an association with a specific new test,
        // we don't need to check what the old test name was or log an extra CONT line
        // for it. (We're updating it anyway, and the current message already includes
        // the test name.)
        p.lastName = testName
        fmt.Fprintf(p.w, format, args...)
}</span>

// Printf prints a message, generated by the named test, that does not
// necessarily mention that tests's name itself.
func (p *chattyPrinter) Printf(testName, format string, args ...interface{}) <span class="cov8" title="1">{
        p.lastNameMu.Lock()
        defer p.lastNameMu.Unlock()

        if p.lastName == "" </span><span class="cov0" title="0">{
                p.lastName = testName
        }</span> else<span class="cov8" title="1"> if p.lastName != testName </span><span class="cov8" title="1">{
                fmt.Fprintf(p.w, "=== CONT  %s\n", testName)
                p.lastName = testName
        }</span>

        <span class="cov8" title="1">fmt.Fprintf(p.w, format, args...)</span>
}

// The maximum number of stack frames to go through when skipping helper functions for
// the purpose of decorating log messages.
const maxStackLen = 50

// common holds the elements common between T and B and
// captures common methods such as Errorf.
type common struct {
        mu          sync.RWMutex        // guards this group of fields
        output      []byte              // Output generated by test or benchmark.
        w           io.Writer           // For flushToParent.
        ran         bool                // Test or benchmark (or one of its subtests) was executed.
        failed      bool                // Test or benchmark has failed.
        skipped     bool                // Test of benchmark has been skipped.
        done        bool                // Test is finished and all subtests have completed.
        helpers     map[string]struct{} // functions to be skipped when writing file/line info
        cleanup     func()              // optional function to be called at the end of the test
        cleanupName string              // Name of the cleanup function.
        cleanupPc   []uintptr           // The stack trace at the point where Cleanup was called.

        chatty     *chattyPrinter // A copy of chattyPrinter, if the chatty flag is set.
        bench      bool           // Whether the current test is a benchmark.
        finished   bool           // Test function has completed.
        hasSub     int32          // Written atomically.
        raceErrors int            // Number of races detected during test.
        runner     string         // Function name of tRunner running the test.

        parent   *common
        level    int       // Nesting depth of test or benchmark.
        creator  []uintptr // If level &gt; 0, the stack trace at the point where the parent called t.Run.
        name     string    // Name of test or benchmark.
        start    time.Time // Time test or benchmark started
        duration time.Duration
        barrier  chan bool // To signal parallel subtests they may start.
        signal   chan bool // To signal a test is done.
        sub      []*T      // Queue of subtests to be run in parallel.

        tempDirOnce sync.Once
        tempDir     string
        tempDirErr  error
        tempDirSeq  int32
}

// Short reports whether the -test.short flag is set.
func Short() bool <span class="cov8" title="1">{
        if short == nil </span><span class="cov0" title="0">{
                panic("testing: Short called before Init")</span>
        }
        // Catch code that calls this from TestMain without first calling flag.Parse.
        <span class="cov8" title="1">if !flag.Parsed() </span><span class="cov0" title="0">{
                panic("testing: Short called before Parse")</span>
        }

        <span class="cov8" title="1">return *short</span>
}

// CoverMode reports what the test coverage mode is set to. The
// values are "set", "count", or "atomic". The return value will be
// empty if test coverage is not enabled.
func CoverMode() string <span class="cov0" title="0">{
        return cover.Mode
}</span>

// Verbose reports whether the -test.v flag is set.
func Verbose() bool <span class="cov8" title="1">{
        // Same as in Short.
        if chatty == nil </span><span class="cov0" title="0">{
                panic("testing: Verbose called before Init")</span>
        }
        <span class="cov8" title="1">if !flag.Parsed() </span><span class="cov0" title="0">{
                panic("testing: Verbose called before Parse")</span>
        }
        <span class="cov8" title="1">return *chatty</span>
}

// frameSkip searches, starting after skip frames, for the first caller frame
// in a function not marked as a helper and returns that frame.
// The search stops if it finds a tRunner function that
// was the entry point into the test and the test is not a subtest.
// This function must be called with c.mu held.
func (c *common) frameSkip(skip int) runtime.Frame <span class="cov8" title="1">{
        // If the search continues into the parent test, we'll have to hold
        // its mu temporarily. If we then return, we need to unlock it.
        shouldUnlock := false
        defer func() </span><span class="cov8" title="1">{
                if shouldUnlock </span><span class="cov8" title="1">{
                        c.mu.Unlock()
                }</span>
        }()
        <span class="cov8" title="1">var pc [maxStackLen]uintptr
        // Skip two extra frames to account for this function
        // and runtime.Callers itself.
        n := runtime.Callers(skip+2, pc[:])
        if n == 0 </span><span class="cov0" title="0">{
                panic("testing: zero callers found")</span>
        }
        <span class="cov8" title="1">frames := runtime.CallersFrames(pc[:n])
        var firstFrame, prevFrame, frame runtime.Frame
        for more := true; more; prevFrame = frame </span><span class="cov8" title="1">{
                frame, more = frames.Next()
                if frame.Function == c.cleanupName </span><span class="cov8" title="1">{
                        frames = runtime.CallersFrames(c.cleanupPc)
                        continue</span>
                }
                <span class="cov8" title="1">if firstFrame.PC == 0 </span><span class="cov8" title="1">{
                        firstFrame = frame
                }</span>
                <span class="cov8" title="1">if frame.Function == c.runner </span><span class="cov8" title="1">{
                        // We've gone up all the way to the tRunner calling
                        // the test function (so the user must have
                        // called tb.Helper from inside that test function).
                        // If this is a top-level test, only skip up to the test function itself.
                        // If we're in a subtest, continue searching in the parent test,
                        // starting from the point of the call to Run which created this subtest.
                        if c.level &gt; 1 </span><span class="cov8" title="1">{
                                frames = runtime.CallersFrames(c.creator)
                                parent := c.parent
                                // We're no longer looking at the current c after this point,
                                // so we should unlock its mu, unless it's the original receiver,
                                // in which case our caller doesn't expect us to do that.
                                if shouldUnlock </span><span class="cov0" title="0">{
                                        c.mu.Unlock()
                                }</span>
                                <span class="cov8" title="1">c = parent
                                // Remember to unlock c.mu when we no longer need it, either
                                // because we went up another nesting level, or because we
                                // returned.
                                shouldUnlock = true
                                c.mu.Lock()
                                continue</span>
                        }
                        <span class="cov8" title="1">return prevFrame</span>
                }
                <span class="cov8" title="1">if _, ok := c.helpers[frame.Function]; !ok </span><span class="cov8" title="1">{
                        // Found a frame that wasn't inside a helper function.
                        return frame
                }</span>
        }
        <span class="cov0" title="0">return firstFrame</span>
}

// decorate prefixes the string with the file and line of the call site
// and inserts the final newline if needed and indentation spaces for formatting.
// This function must be called with c.mu held.
func (c *common) decorate(s string, skip int) string <span class="cov8" title="1">{
        frame := c.frameSkip(skip)
        file := frame.File
        line := frame.Line
        if file != "" </span><span class="cov8" title="1">{
                // Truncate file name at last file name separator.
                if index := strings.LastIndex(file, "/"); index &gt;= 0 </span><span class="cov8" title="1">{
                        file = file[index+1:]
                }</span> else<span class="cov0" title="0"> if index = strings.LastIndex(file, "\\"); index &gt;= 0 </span><span class="cov0" title="0">{
                        file = file[index+1:]
                }</span>
        } else<span class="cov0" title="0"> {
                file = "???"
        }</span>
        <span class="cov8" title="1">if line == 0 </span><span class="cov0" title="0">{
                line = 1
        }</span>
        <span class="cov8" title="1">buf := new(strings.Builder)
        // Every line is indented at least 4 spaces.
        buf.WriteString("    ")
        fmt.Fprintf(buf, "%s:%d: ", file, line)
        lines := strings.Split(s, "\n")
        if l := len(lines); l &gt; 1 &amp;&amp; lines[l-1] == "" </span><span class="cov8" title="1">{
                lines = lines[:l-1]
        }</span>
        <span class="cov8" title="1">for i, line := range lines </span><span class="cov8" title="1">{
                if i &gt; 0 </span><span class="cov0" title="0">{
                        // Second and subsequent lines are indented an additional 4 spaces.
                        buf.WriteString("\n        ")
                }</span>
                <span class="cov8" title="1">buf.WriteString(line)</span>
        }
        <span class="cov8" title="1">buf.WriteByte('\n')
        return buf.String()</span>
}

// flushToParent writes c.output to the parent after first writing the header
// with the given format and arguments.
func (c *common) flushToParent(testName, format string, args ...interface{}) <span class="cov8" title="1">{
        p := c.parent
        p.mu.Lock()
        defer p.mu.Unlock()

        c.mu.Lock()
        defer c.mu.Unlock()

        if len(c.output) &gt; 0 </span><span class="cov8" title="1">{
                format += "%s"
                args = append(args[:len(args):len(args)], c.output)
                c.output = c.output[:0] // but why?
        }</span>

        <span class="cov8" title="1">if c.chatty != nil &amp;&amp; p.w == c.chatty.w </span><span class="cov8" title="1">{
                // We're flushing to the actual output, so track that this output is
                // associated with a specific test (and, specifically, that the next output
                // is *not* associated with that test).
                //
                // Moreover, if c.output is non-empty it is important that this write be
                // atomic with respect to the output of other tests, so that we don't end up
                // with confusing '=== CONT' lines in the middle of our '--- PASS' block.
                // Neither humans nor cmd/test2json can parse those easily.
                // (See https://golang.org/issue/40771.)
                c.chatty.Updatef(testName, format, args...)
        }</span> else<span class="cov8" title="1"> {
                // We're flushing to the output buffer of the parent test, which will
                // itself follow a test-name header when it is finally flushed to stdout.
                fmt.Fprintf(p.w, format, args...)
        }</span>
}

type indenter struct {
        c *common
}

func (w indenter) Write(b []byte) (n int, err error) <span class="cov8" title="1">{
        n = len(b)
        for len(b) &gt; 0 </span><span class="cov8" title="1">{
                end := bytes.IndexByte(b, '\n')
                if end == -1 </span><span class="cov0" title="0">{
                        end = len(b)
                }</span> else<span class="cov8" title="1"> {
                        end++
                }</span>
                // An indent of 4 spaces will neatly align the dashes with the status
                // indicator of the parent.
                <span class="cov8" title="1">const indent = "    "
                w.c.output = append(w.c.output, indent...)
                w.c.output = append(w.c.output, b[:end]...)
                b = b[end:]</span>
        }
        <span class="cov8" title="1">return</span>
}

// fmtDuration returns a string representing d in the form "87.00s".
func fmtDuration(d time.Duration) string <span class="cov8" title="1">{
        return fmt.Sprintf("%.2fs", d.Seconds())
}</span>

// TB is the interface common to T and B.
type TB interface {
        Cleanup(func())
        Error(args ...interface{})
        Errorf(format string, args ...interface{})
        Fail()
        FailNow()
        Failed() bool
        Fatal(args ...interface{})
        Fatalf(format string, args ...interface{})
        Helper()
        Log(args ...interface{})
        Logf(format string, args ...interface{})
        Name() string
        Skip(args ...interface{})
        SkipNow()
        Skipf(format string, args ...interface{})
        Skipped() bool
        TempDir() string

        // A private method to prevent users implementing the
        // interface and so future additions to it will not
        // violate Go 1 compatibility.
        private()
}

var _ TB = (*T)(nil)
var _ TB = (*B)(nil)

// T is a type passed to Test functions to manage test state and support formatted test logs.
//
// A test ends when its Test function returns or calls any of the methods
// FailNow, Fatal, Fatalf, SkipNow, Skip, or Skipf. Those methods, as well as
// the Parallel method, must be called only from the goroutine running the
// Test function.
//
// The other reporting methods, such as the variations of Log and Error,
// may be called simultaneously from multiple goroutines.
type T struct {
        common
        isParallel bool
        context    *testContext // For running tests and subtests.
}

func (c *common) private() {<span class="cov0" title="0">}</span>

// Name returns the name of the running test or benchmark.
func (c *common) Name() string <span class="cov8" title="1">{
        return c.name
}</span>

func (c *common) setRan() <span class="cov8" title="1">{
        if c.parent != nil </span><span class="cov8" title="1">{
                c.parent.setRan()
        }</span>
        <span class="cov8" title="1">c.mu.Lock()
        defer c.mu.Unlock()
        c.ran = true</span>
}

// Fail marks the function as having failed but continues execution.
func (c *common) Fail() <span class="cov8" title="1">{
        if c.parent != nil </span><span class="cov8" title="1">{
                c.parent.Fail()
        }</span>
        <span class="cov8" title="1">c.mu.Lock()
        defer c.mu.Unlock()
        // c.done needs to be locked to synchronize checks to c.done in parent tests.
        if c.done </span><span class="cov8" title="1">{
                panic("Fail in goroutine after " + c.name + " has completed")</span>
        }
        <span class="cov8" title="1">c.failed = true</span>
}

// Failed reports whether the function has failed.
func (c *common) Failed() bool <span class="cov8" title="1">{
        c.mu.RLock()
        failed := c.failed
        c.mu.RUnlock()
        return failed || c.raceErrors+race.Errors() &gt; 0
}</span>

// FailNow marks the function as having failed and stops its execution
// by calling runtime.Goexit (which then runs all deferred calls in the
// current goroutine).
// Execution will continue at the next test or benchmark.
// FailNow must be called from the goroutine running the
// test or benchmark function, not from other goroutines
// created during the test. Calling FailNow does not stop
// those other goroutines.
func (c *common) FailNow() <span class="cov8" title="1">{
        c.Fail()

        // Calling runtime.Goexit will exit the goroutine, which
        // will run the deferred functions in this goroutine,
        // which will eventually run the deferred lines in tRunner,
        // which will signal to the test loop that this test is done.
        //
        // A previous version of this code said:
        //
        //        c.duration = ...
        //        c.signal &lt;- c.self
        //        runtime.Goexit()
        //
        // This previous version duplicated code (those lines are in
        // tRunner no matter what), but worse the goroutine teardown
        // implicit in runtime.Goexit was not guaranteed to complete
        // before the test exited. If a test deferred an important cleanup
        // function (like removing temporary files), there was no guarantee
        // it would run on a test failure. Because we send on c.signal during
        // a top-of-stack deferred function now, we know that the send
        // only happens after any other stacked defers have completed.
        c.finished = true
        runtime.Goexit()
}</span>

// log generates the output. It's always at the same stack depth.
func (c *common) log(s string) <span class="cov8" title="1">{
        c.logDepth(s, 3) // logDepth + log + public function
}</span>

// logDepth generates the output at an arbitrary stack depth.
func (c *common) logDepth(s string, depth int) <span class="cov8" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()
        if c.done </span><span class="cov8" title="1">{
                // This test has already finished. Try and log this message
                // with our parent. If we don't have a parent, panic.
                for parent := c.parent; parent != nil; parent = parent.parent </span><span class="cov8" title="1">{
                        parent.mu.Lock()
                        defer parent.mu.Unlock()
                        if !parent.done </span><span class="cov8" title="1">{
                                parent.output = append(parent.output, parent.decorate(s, depth+1)...)
                                return
                        }</span>
                }
                <span class="cov8" title="1">panic("Log in goroutine after " + c.name + " has completed")</span>
        } else<span class="cov8" title="1"> {
                if c.chatty != nil </span><span class="cov8" title="1">{
                        if c.bench </span><span class="cov0" title="0">{
                                // Benchmarks don't print === CONT, so we should skip the test
                                // printer and just print straight to stdout.
                                fmt.Print(c.decorate(s, depth+1))
                        }</span> else<span class="cov8" title="1"> {
                                c.chatty.Printf(c.name, "%s", c.decorate(s, depth+1))
                        }</span>

                        <span class="cov8" title="1">return</span>
                }
                <span class="cov8" title="1">c.output = append(c.output, c.decorate(s, depth+1)...)</span>
        }
}

// Log formats its arguments using default formatting, analogous to Println,
// and records the text in the error log. For tests, the text will be printed only if
// the test fails or the -test.v flag is set. For benchmarks, the text is always
// printed to avoid having performance depend on the value of the -test.v flag.
func (c *common) Log(args ...interface{}) <span class="cov8" title="1">{ c.log(fmt.Sprintln(args...)) }</span>

// Logf formats its arguments according to the format, analogous to Printf, and
// records the text in the error log. A final newline is added if not provided. For
// tests, the text will be printed only if the test fails or the -test.v flag is
// set. For benchmarks, the text is always printed to avoid having performance
// depend on the value of the -test.v flag.
func (c *common) Logf(format string, args ...interface{}) <span class="cov8" title="1">{ c.log(fmt.Sprintf(format, args...)) }</span>

// Error is equivalent to Log followed by Fail.
func (c *common) Error(args ...interface{}) <span class="cov8" title="1">{
        c.log(fmt.Sprintln(args...))
        c.Fail()
}</span>

// Errorf is equivalent to Logf followed by Fail.
func (c *common) Errorf(format string, args ...interface{}) <span class="cov8" title="1">{
        c.log(fmt.Sprintf(format, args...))
        c.Fail()
}</span>

// Fatal is equivalent to Log followed by FailNow.
func (c *common) Fatal(args ...interface{}) <span class="cov0" title="0">{
        c.log(fmt.Sprintln(args...))
        c.FailNow()
}</span>

// Fatalf is equivalent to Logf followed by FailNow.
func (c *common) Fatalf(format string, args ...interface{}) <span class="cov8" title="1">{
        c.log(fmt.Sprintf(format, args...))
        c.FailNow()
}</span>

// Skip is equivalent to Log followed by SkipNow.
func (c *common) Skip(args ...interface{}) <span class="cov8" title="1">{
        c.log(fmt.Sprintln(args...))
        c.SkipNow()
}</span>

// Skipf is equivalent to Logf followed by SkipNow.
func (c *common) Skipf(format string, args ...interface{}) <span class="cov0" title="0">{
        c.log(fmt.Sprintf(format, args...))
        c.SkipNow()
}</span>

// SkipNow marks the test as having been skipped and stops its execution
// by calling runtime.Goexit.
// If a test fails (see Error, Errorf, Fail) and is then skipped,
// it is still considered to have failed.
// Execution will continue at the next test or benchmark. See also FailNow.
// SkipNow must be called from the goroutine running the test, not from
// other goroutines created during the test. Calling SkipNow does not stop
// those other goroutines.
func (c *common) SkipNow() <span class="cov8" title="1">{
        c.skip()
        c.finished = true
        runtime.Goexit()
}</span>

func (c *common) skip() <span class="cov8" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()
        c.skipped = true
}</span>

// Skipped reports whether the test was skipped.
func (c *common) Skipped() bool <span class="cov8" title="1">{
        c.mu.RLock()
        defer c.mu.RUnlock()
        return c.skipped
}</span>

// Helper marks the calling function as a test helper function.
// When printing file and line information, that function will be skipped.
// Helper may be called simultaneously from multiple goroutines.
func (c *common) Helper() <span class="cov8" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()
        if c.helpers == nil </span><span class="cov8" title="1">{
                c.helpers = make(map[string]struct{})
        }</span>
        <span class="cov8" title="1">c.helpers[callerName(1)] = struct{}{}</span>
}

// Cleanup registers a function to be called when the test and all its
// subtests complete. Cleanup functions will be called in last added,
// first called order.
func (c *common) Cleanup(f func()) <span class="cov8" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()
        oldCleanup := c.cleanup
        oldCleanupPc := c.cleanupPc
        c.cleanup = func() </span><span class="cov8" title="1">{
                if oldCleanup != nil </span><span class="cov8" title="1">{
                        defer func() </span><span class="cov8" title="1">{
                                c.mu.Lock()
                                c.cleanupPc = oldCleanupPc
                                c.mu.Unlock()
                                oldCleanup()
                        }</span>()
                }
                <span class="cov8" title="1">c.mu.Lock()
                c.cleanupName = callerName(0)
                c.mu.Unlock()
                f()</span>
        }
        <span class="cov8" title="1">var pc [maxStackLen]uintptr
        // Skip two extra frames to account for this function and runtime.Callers itself.
        n := runtime.Callers(2, pc[:])
        c.cleanupPc = pc[:n]</span>
}

var tempDirReplacer struct {
        sync.Once
        r *strings.Replacer
}

// TempDir returns a temporary directory for the test to use.
// The directory is automatically removed by Cleanup when the test and
// all its subtests complete.
// Each subsequent call to t.TempDir returns a unique directory;
// if the directory creation fails, TempDir terminates the test by calling Fatal.
func (c *common) TempDir() string <span class="cov8" title="1">{
        // Use a single parent directory for all the temporary directories
        // created by a test, each numbered sequentially.
        c.tempDirOnce.Do(func() </span><span class="cov8" title="1">{
                c.Helper()

                // ioutil.TempDir doesn't like path separators in its pattern,
                // so mangle the name to accommodate subtests.
                tempDirReplacer.Do(func() </span><span class="cov8" title="1">{
                        tempDirReplacer.r = strings.NewReplacer("/", "_", "\\", "_", ":", "_")
                }</span>)
                <span class="cov8" title="1">pattern := tempDirReplacer.r.Replace(c.Name())

                c.tempDir, c.tempDirErr = ioutil.TempDir("", pattern)
                if c.tempDirErr == nil </span><span class="cov8" title="1">{
                        c.Cleanup(func() </span><span class="cov8" title="1">{
                                if err := os.RemoveAll(c.tempDir); err != nil </span><span class="cov0" title="0">{
                                        c.Errorf("TempDir RemoveAll cleanup: %v", err)
                                }</span>
                        })
                }
        })
        <span class="cov8" title="1">if c.tempDirErr != nil </span><span class="cov0" title="0">{
                c.Fatalf("TempDir: %v", c.tempDirErr)
        }</span>
        <span class="cov8" title="1">seq := atomic.AddInt32(&amp;c.tempDirSeq, 1)
        dir := fmt.Sprintf("%s%c%03d", c.tempDir, os.PathSeparator, seq)
        if err := os.Mkdir(dir, 0777); err != nil </span><span class="cov0" title="0">{
                c.Fatalf("TempDir: %v", err)
        }</span>
        <span class="cov8" title="1">return dir</span>
}

// panicHanding is an argument to runCleanup.
type panicHandling int

const (
        normalPanic panicHandling = iota
        recoverAndReturnPanic
)

// runCleanup is called at the end of the test.
// If catchPanic is true, this will catch panics, and return the recovered
// value if any.
func (c *common) runCleanup(ph panicHandling) (panicVal interface{}) <span class="cov8" title="1">{
        c.mu.Lock()
        cleanup := c.cleanup
        c.cleanup = nil
        c.mu.Unlock()
        if cleanup == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">if ph == recoverAndReturnPanic </span><span class="cov8" title="1">{
                defer func() </span><span class="cov8" title="1">{
                        panicVal = recover()
                }</span>()
        }

        <span class="cov8" title="1">cleanup()
        return nil</span>
}

// callerName gives the function name (qualified with a package path)
// for the caller after skip frames (where 0 means the current function).
func callerName(skip int) string <span class="cov8" title="1">{
        // Make room for the skip PC.
        var pc [1]uintptr
        n := runtime.Callers(skip+2, pc[:]) // skip + runtime.Callers + callerName
        if n == 0 </span><span class="cov0" title="0">{
                panic("testing: zero callers found")</span>
        }
        <span class="cov8" title="1">frames := runtime.CallersFrames(pc[:n])
        frame, _ := frames.Next()
        return frame.Function</span>
}

// Parallel signals that this test is to be run in parallel with (and only with)
// other parallel tests. When a test is run multiple times due to use of
// -test.count or -test.cpu, multiple instances of a single test never run in
// parallel with each other.
func (t *T) Parallel() <span class="cov8" title="1">{
        if t.isParallel </span><span class="cov0" title="0">{
                panic("testing: t.Parallel called multiple times")</span>
        }
        <span class="cov8" title="1">t.isParallel = true

        // We don't want to include the time we spend waiting for serial tests
        // in the test duration. Record the elapsed time thus far and reset the
        // timer afterwards.
        t.duration += time.Since(t.start)

        // Add to the list of tests to be released by the parent.
        t.parent.sub = append(t.parent.sub, t)
        t.raceErrors += race.Errors()

        if t.chatty != nil </span><span class="cov8" title="1">{
                // Unfortunately, even though PAUSE indicates that the named test is *no
                // longer* running, cmd/test2json interprets it as changing the active test
                // for the purpose of log parsing. We could fix cmd/test2json, but that
                // won't fix existing deployments of third-party tools that already shell
                // out to older builds of cmd/test2json — so merely fixing cmd/test2json
                // isn't enough for now.
                t.chatty.Updatef(t.name, "=== PAUSE %s\n", t.name)
        }</span>

        <span class="cov8" title="1">t.signal &lt;- true   // Release calling test.
        &lt;-t.parent.barrier // Wait for the parent test to complete.
        t.context.waitParallel()

        if t.chatty != nil </span><span class="cov8" title="1">{
                t.chatty.Updatef(t.name, "=== CONT  %s\n", t.name)
        }</span>

        <span class="cov8" title="1">t.start = time.Now()
        t.raceErrors += -race.Errors()</span>
}

// InternalTest is an internal type but exported because it is cross-package;
// it is part of the implementation of the "go test" command.
type InternalTest struct {
        Name string
        F    func(*T)
}

var errNilPanicOrGoexit = errors.New("test executed panic(nil) or runtime.Goexit")

func tRunner(t *T, fn func(t *T)) <span class="cov8" title="1">{
        t.runner = callerName(0)

        // When this goroutine is done, either because fn(t)
        // returned normally or because a test failure triggered
        // a call to runtime.Goexit, record the duration and send
        // a signal saying that the test is done.
        defer func() </span><span class="cov8" title="1">{
                if t.Failed() </span><span class="cov8" title="1">{
                        atomic.AddUint32(&amp;numFailed, 1)
                }</span>

                <span class="cov8" title="1">if t.raceErrors+race.Errors() &gt; 0 </span><span class="cov0" title="0">{
                        t.Errorf("race detected during execution of test")
                }</span>

                // If the test panicked, print any test output before dying.
                <span class="cov8" title="1">err := recover()
                signal := true
                if !t.finished &amp;&amp; err == nil </span><span class="cov8" title="1">{
                        err = errNilPanicOrGoexit
                        for p := t.parent; p != nil; p = p.parent </span><span class="cov8" title="1">{
                                if p.finished </span><span class="cov8" title="1">{
                                        t.Errorf("%v: subtest may have called FailNow on a parent test", err)
                                        err = nil
                                        signal = false
                                        break</span>
                                }
                        }
                }

                <span class="cov8" title="1">doPanic := func(err interface{}) </span><span class="cov0" title="0">{
                        t.Fail()
                        if r := t.runCleanup(recoverAndReturnPanic); r != nil </span><span class="cov0" title="0">{
                                t.Logf("cleanup panicked with %v", r)
                        }</span>
                        // Flush the output log up to the root before dying.
                        <span class="cov0" title="0">for root := &amp;t.common; root.parent != nil; root = root.parent </span><span class="cov0" title="0">{
                                root.mu.Lock()
                                root.duration += time.Since(root.start)
                                d := root.duration
                                root.mu.Unlock()
                                root.flushToParent(root.name, "--- FAIL: %s (%s)\n", root.name, fmtDuration(d))
                                if r := root.parent.runCleanup(recoverAndReturnPanic); r != nil </span><span class="cov0" title="0">{
                                        fmt.Fprintf(root.parent.w, "cleanup panicked with %v", r)
                                }</span>
                        }
                        <span class="cov0" title="0">panic(err)</span>
                }
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        doPanic(err)
                }</span>

                <span class="cov8" title="1">t.duration += time.Since(t.start)

                if len(t.sub) &gt; 0 </span><span class="cov8" title="1">{
                        // Run parallel subtests.
                        // Decrease the running count for this test.
                        t.context.release()
                        // Release the parallel subtests.
                        close(t.barrier)
                        // Wait for subtests to complete.
                        for _, sub := range t.sub </span><span class="cov8" title="1">{
                                &lt;-sub.signal
                        }</span>
                        <span class="cov8" title="1">cleanupStart := time.Now()
                        err := t.runCleanup(recoverAndReturnPanic)
                        t.duration += time.Since(cleanupStart)
                        if err != nil </span><span class="cov0" title="0">{
                                doPanic(err)
                        }</span>
                        <span class="cov8" title="1">if !t.isParallel </span><span class="cov8" title="1">{
                                // Reacquire the count for sequential tests. See comment in Run.
                                t.context.waitParallel()
                        }</span>
                } else<span class="cov8" title="1"> if t.isParallel </span><span class="cov8" title="1">{
                        // Only release the count for this test if it was run as a parallel
                        // test. See comment in Run method.
                        t.context.release()
                }</span>
                <span class="cov8" title="1">t.report() // Report after all subtests have finished.

                // Do not lock t.done to allow race detector to detect race in case
                // the user does not appropriately synchronizes a goroutine.
                t.done = true
                if t.parent != nil &amp;&amp; atomic.LoadInt32(&amp;t.hasSub) == 0 </span><span class="cov8" title="1">{
                        t.setRan()
                }</span>
                <span class="cov8" title="1">t.signal &lt;- signal</span>
        }()
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if len(t.sub) == 0 </span><span class="cov8" title="1">{
                        t.runCleanup(normalPanic)
                }</span>
        }()

        <span class="cov8" title="1">t.start = time.Now()
        t.raceErrors = -race.Errors()
        fn(t)

        // code beyond here will not be executed when FailNow is invoked
        t.finished = true</span>
}

// Run runs f as a subtest of t called name. It runs f in a separate goroutine
// and blocks until f returns or calls t.Parallel to become a parallel test.
// Run reports whether f succeeded (or at least did not fail before calling t.Parallel).
//
// Run may be called simultaneously from multiple goroutines, but all such calls
// must return before the outer test function for t returns.
func (t *T) Run(name string, f func(t *T)) bool <span class="cov8" title="1">{
        atomic.StoreInt32(&amp;t.hasSub, 1)
        testName, ok, _ := t.context.match.fullName(&amp;t.common, name)
        if !ok || shouldFailFast() </span><span class="cov0" title="0">{
                return true
        }</span>
        // Record the stack trace at the point of this call so that if the subtest
        // function - which runs in a separate stack - is marked as a helper, we can
        // continue walking the stack into the parent test.
        <span class="cov8" title="1">var pc [maxStackLen]uintptr
        n := runtime.Callers(2, pc[:])
        t = &amp;T{
                common: common{
                        barrier: make(chan bool),
                        signal:  make(chan bool),
                        name:    testName,
                        parent:  &amp;t.common,
                        level:   t.level + 1,
                        creator: pc[:n],
                        chatty:  t.chatty,
                },
                context: t.context,
        }
        t.w = indenter{&amp;t.common}

        if t.chatty != nil </span><span class="cov8" title="1">{
                t.chatty.Updatef(t.name, "=== RUN   %s\n", t.name)
        }</span>
        // Instead of reducing the running count of this test before calling the
        // tRunner and increasing it afterwards, we rely on tRunner keeping the
        // count correct. This ensures that a sequence of sequential tests runs
        // without being preempted, even when their parent is a parallel test. This
        // may especially reduce surprises if *parallel == 1.
        <span class="cov8" title="1">go tRunner(t, f)
        if !&lt;-t.signal </span><span class="cov8" title="1">{
                // At this point, it is likely that FailNow was called on one of the
                // parent tests by one of the subtests. Continue aborting up the chain.
                runtime.Goexit()
        }</span>
        <span class="cov8" title="1">return !t.failed</span>
}

// Deadline reports the time at which the test binary will have
// exceeded the timeout specified by the -timeout flag.
//
// The ok result is false if the -timeout flag indicates “no timeout” (0).
func (t *T) Deadline() (deadline time.Time, ok bool) <span class="cov0" title="0">{
        deadline = t.context.deadline
        return deadline, !deadline.IsZero()
}</span>

// testContext holds all fields that are common to all tests. This includes
// synchronization primitives to run at most *parallel tests.
type testContext struct {
        match    *matcher
        deadline time.Time

        mu sync.Mutex

        // Channel used to signal tests that are ready to be run in parallel.
        startParallel chan bool

        // running is the number of tests currently running in parallel.
        // This does not include tests that are waiting for subtests to complete.
        running int

        // numWaiting is the number tests waiting to be run in parallel.
        numWaiting int

        // maxParallel is a copy of the parallel flag.
        maxParallel int
}

func newTestContext(maxParallel int, m *matcher) *testContext <span class="cov8" title="1">{
        return &amp;testContext{
                match:         m,
                startParallel: make(chan bool),
                maxParallel:   maxParallel,
                running:       1, // Set the count to 1 for the main (sequential) test.
        }
}</span>

func (c *testContext) waitParallel() <span class="cov8" title="1">{
        c.mu.Lock()
        if c.running &lt; c.maxParallel </span><span class="cov8" title="1">{
                c.running++
                c.mu.Unlock()
                return
        }</span>
        <span class="cov8" title="1">c.numWaiting++
        c.mu.Unlock()
        &lt;-c.startParallel</span>
}

func (c *testContext) release() <span class="cov8" title="1">{
        c.mu.Lock()
        if c.numWaiting == 0 </span><span class="cov8" title="1">{
                c.running--
                c.mu.Unlock()
                return
        }</span>
        <span class="cov8" title="1">c.numWaiting--
        c.mu.Unlock()
        c.startParallel &lt;- true</span> // Pick a waiting test to be run.
}

// No one should be using func Main anymore.
// See the doc comment on func Main and use MainStart instead.
var errMain = errors.New("testing: unexpected use of func Main")

type matchStringOnly func(pat, str string) (bool, error)

func (f matchStringOnly) MatchString(pat, str string) (bool, error)   <span class="cov0" title="0">{ return f(pat, str) }</span>
func (f matchStringOnly) StartCPUProfile(w io.Writer) error           <span class="cov0" title="0">{ return errMain }</span>
func (f matchStringOnly) StopCPUProfile()                             {<span class="cov0" title="0">}</span>
func (f matchStringOnly) WriteProfileTo(string, io.Writer, int) error <span class="cov0" title="0">{ return errMain }</span>
func (f matchStringOnly) ImportPath() string                          <span class="cov0" title="0">{ return "" }</span>
func (f matchStringOnly) StartTestLog(io.Writer)                      {<span class="cov0" title="0">}</span>
func (f matchStringOnly) StopTestLog() error                          <span class="cov0" title="0">{ return errMain }</span>

// Main is an internal function, part of the implementation of the "go test" command.
// It was exported because it is cross-package and predates "internal" packages.
// It is no longer used by "go test" but preserved, as much as possible, for other
// systems that simulate "go test" using Main, but Main sometimes cannot be updated as
// new functionality is added to the testing package.
// Systems simulating "go test" should be updated to use MainStart.
func Main(matchString func(pat, str string) (bool, error), tests []InternalTest, benchmarks []InternalBenchmark, examples []InternalExample) <span class="cov0" title="0">{
        os.Exit(MainStart(matchStringOnly(matchString), tests, benchmarks, examples).Run())
}</span>

// M is a type passed to a TestMain function to run the actual tests.
type M struct {
        deps       testDeps
        tests      []InternalTest
        benchmarks []InternalBenchmark
        examples   []InternalExample

        timer     *time.Timer
        afterOnce sync.Once

        numRun int

        // value to pass to os.Exit, the outer test func main
        // harness calls os.Exit with this code. See #34129.
        exitCode int
}

// testDeps is an internal interface of functionality that is
// passed into this package by a test's generated main package.
// The canonical implementation of this interface is
// testing/internal/testdeps's TestDeps.
type testDeps interface {
        ImportPath() string
        MatchString(pat, str string) (bool, error)
        StartCPUProfile(io.Writer) error
        StopCPUProfile()
        StartTestLog(io.Writer)
        StopTestLog() error
        WriteProfileTo(string, io.Writer, int) error
}

// MainStart is meant for use by tests generated by 'go test'.
// It is not meant to be called directly and is not subject to the Go 1 compatibility document.
// It may change signature from release to release.
func MainStart(deps testDeps, tests []InternalTest, benchmarks []InternalBenchmark, examples []InternalExample) *M <span class="cov8" title="1">{
        Init()
        return &amp;M{
                deps:       deps,
                tests:      tests,
                benchmarks: benchmarks,
                examples:   examples,
        }
}</span>

// Run runs the tests. It returns an exit code to pass to os.Exit.
func (m *M) Run() (code int) <span class="cov8" title="1">{
        defer func() </span><span class="cov0" title="0">{
                code = m.exitCode
        }</span>()

        // Count the number of calls to m.Run.
        // We only ever expected 1, but we didn't enforce that,
        // and now there are tests in the wild that call m.Run multiple times.
        // Sigh. golang.org/issue/23129.
        <span class="cov8" title="1">m.numRun++

        // TestMain may have already called flag.Parse.
        if !flag.Parsed() </span><span class="cov8" title="1">{
                flag.Parse()
        }</span>

        <span class="cov8" title="1">if *parallel &lt; 1 </span><span class="cov0" title="0">{
                fmt.Fprintln(os.Stderr, "testing: -parallel can only be given a positive integer")
                flag.Usage()
                m.exitCode = 2
                return
        }</span>

        <span class="cov8" title="1">if len(*matchList) != 0 </span><span class="cov0" title="0">{
                listTests(m.deps.MatchString, m.tests, m.benchmarks, m.examples)
                m.exitCode = 0
                return
        }</span>

        <span class="cov8" title="1">parseCpuList()

        m.before()
        defer m.after()
        deadline := m.startAlarm()
        haveExamples = len(m.examples) &gt; 0
        testRan, testOk := runTests(m.deps.MatchString, m.tests, deadline)
        exampleRan, exampleOk := runExamples(m.deps.MatchString, m.examples)
        m.stopAlarm()
        if !testRan &amp;&amp; !exampleRan &amp;&amp; *matchBenchmarks == "" </span><span class="cov0" title="0">{
                fmt.Fprintln(os.Stderr, "testing: warning: no tests to run")
        }</span>
        <span class="cov8" title="1">if !testOk || !exampleOk || !runBenchmarks(m.deps.ImportPath(), m.deps.MatchString, m.benchmarks) || race.Errors() &gt; 0 </span><span class="cov0" title="0">{
                fmt.Println("FAIL")
                m.exitCode = 1
                return
        }</span>

        <span class="cov8" title="1">fmt.Println("PASS")
        m.exitCode = 0
        return</span>
}

func (t *T) report() <span class="cov8" title="1">{
        if t.parent == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">dstr := fmtDuration(t.duration)
        format := "--- %s: %s (%s)\n"
        if t.Failed() </span><span class="cov8" title="1">{
                t.flushToParent(t.name, format, "FAIL", t.name, dstr)
        }</span> else<span class="cov8" title="1"> if t.chatty != nil </span><span class="cov8" title="1">{
                if t.Skipped() </span><span class="cov8" title="1">{
                        t.flushToParent(t.name, format, "SKIP", t.name, dstr)
                }</span> else<span class="cov8" title="1"> {
                        t.flushToParent(t.name, format, "PASS", t.name, dstr)
                }</span>
        }
}

func listTests(matchString func(pat, str string) (bool, error), tests []InternalTest, benchmarks []InternalBenchmark, examples []InternalExample) <span class="cov0" title="0">{
        if _, err := matchString(*matchList, "non-empty"); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "testing: invalid regexp in -test.list (%q): %s\n", *matchList, err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">for _, test := range tests </span><span class="cov0" title="0">{
                if ok, _ := matchString(*matchList, test.Name); ok </span><span class="cov0" title="0">{
                        fmt.Println(test.Name)
                }</span>
        }
        <span class="cov0" title="0">for _, bench := range benchmarks </span><span class="cov0" title="0">{
                if ok, _ := matchString(*matchList, bench.Name); ok </span><span class="cov0" title="0">{
                        fmt.Println(bench.Name)
                }</span>
        }
        <span class="cov0" title="0">for _, example := range examples </span><span class="cov0" title="0">{
                if ok, _ := matchString(*matchList, example.Name); ok </span><span class="cov0" title="0">{
                        fmt.Println(example.Name)
                }</span>
        }
}

// RunTests is an internal function but exported because it is cross-package;
// it is part of the implementation of the "go test" command.
func RunTests(matchString func(pat, str string) (bool, error), tests []InternalTest) (ok bool) <span class="cov0" title="0">{
        var deadline time.Time
        if *timeout &gt; 0 </span><span class="cov0" title="0">{
                deadline = time.Now().Add(*timeout)
        }</span>
        <span class="cov0" title="0">ran, ok := runTests(matchString, tests, deadline)
        if !ran &amp;&amp; !haveExamples </span><span class="cov0" title="0">{
                fmt.Fprintln(os.Stderr, "testing: warning: no tests to run")
        }</span>
        <span class="cov0" title="0">return ok</span>
}

func runTests(matchString func(pat, str string) (bool, error), tests []InternalTest, deadline time.Time) (ran, ok bool) <span class="cov8" title="1">{
        ok = true
        for _, procs := range cpuList </span><span class="cov8" title="1">{
                runtime.GOMAXPROCS(procs)
                for i := uint(0); i &lt; *count; i++ </span><span class="cov8" title="1">{
                        if shouldFailFast() </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov8" title="1">ctx := newTestContext(*parallel, newMatcher(matchString, *match, "-test.run"))
                        ctx.deadline = deadline
                        t := &amp;T{
                                common: common{
                                        signal:  make(chan bool),
                                        barrier: make(chan bool),
                                        w:       os.Stdout,
                                },
                                context: ctx,
                        }
                        if Verbose() </span><span class="cov8" title="1">{
                                t.chatty = newChattyPrinter(t.w)
                        }</span>
                        <span class="cov8" title="1">tRunner(t, func(t *T) </span><span class="cov8" title="1">{
                                for _, test := range tests </span><span class="cov8" title="1">{
                                        t.Run(test.Name, test.F)
                                }</span>
                                // Run catching the signal rather than the tRunner as a separate
                                // goroutine to avoid adding a goroutine during the sequential
                                // phase as this pollutes the stacktrace output when aborting.
                                <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{ &lt;-t.signal }</span>()
                        })
                        <span class="cov8" title="1">ok = ok &amp;&amp; !t.Failed()
                        ran = ran || t.ran</span>
                }
        }
        <span class="cov8" title="1">return ran, ok</span>
}

// before runs before all testing.
func (m *M) before() <span class="cov8" title="1">{
        if *memProfileRate &gt; 0 </span><span class="cov0" title="0">{
                runtime.MemProfileRate = *memProfileRate
        }</span>
        <span class="cov8" title="1">if *cpuProfile != "" </span><span class="cov0" title="0">{
                f, err := os.Create(toOutputDir(*cpuProfile))
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "testing: %s\n", err)
                        return
                }</span>
                <span class="cov0" title="0">if err := m.deps.StartCPUProfile(f); err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "testing: can't start cpu profile: %s\n", err)
                        f.Close()
                        return
                }</span>
                // Could save f so after can call f.Close; not worth the effort.
        }
        <span class="cov8" title="1">if *traceFile != "" </span><span class="cov0" title="0">{
                f, err := os.Create(toOutputDir(*traceFile))
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "testing: %s\n", err)
                        return
                }</span>
                <span class="cov0" title="0">if err := trace.Start(f); err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "testing: can't start tracing: %s\n", err)
                        f.Close()
                        return
                }</span>
                // Could save f so after can call f.Close; not worth the effort.
        }
        <span class="cov8" title="1">if *blockProfile != "" &amp;&amp; *blockProfileRate &gt;= 0 </span><span class="cov0" title="0">{
                runtime.SetBlockProfileRate(*blockProfileRate)
        }</span>
        <span class="cov8" title="1">if *mutexProfile != "" &amp;&amp; *mutexProfileFraction &gt;= 0 </span><span class="cov0" title="0">{
                runtime.SetMutexProfileFraction(*mutexProfileFraction)
        }</span>
        <span class="cov8" title="1">if *coverProfile != "" &amp;&amp; cover.Mode == "" </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "testing: cannot use -test.coverprofile because test binary was not built with coverage enabled\n")
                os.Exit(2)
        }</span>
        <span class="cov8" title="1">if *testlog != "" </span><span class="cov0" title="0">{
                // Note: Not using toOutputDir.
                // This file is for use by cmd/go, not users.
                var f *os.File
                var err error
                if m.numRun == 1 </span><span class="cov0" title="0">{
                        f, err = os.Create(*testlog)
                }</span> else<span class="cov0" title="0"> {
                        f, err = os.OpenFile(*testlog, os.O_WRONLY, 0)
                        if err == nil </span><span class="cov0" title="0">{
                                f.Seek(0, io.SeekEnd)
                        }</span>
                }
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "testing: %s\n", err)
                        os.Exit(2)
                }</span>
                <span class="cov0" title="0">m.deps.StartTestLog(f)
                testlogFile = f</span>
        }
}

// after runs after all testing.
func (m *M) after() <span class="cov8" title="1">{
        m.afterOnce.Do(func() </span><span class="cov8" title="1">{
                m.writeProfiles()
        }</span>)
}

func (m *M) writeProfiles() <span class="cov8" title="1">{
        if *testlog != "" </span><span class="cov0" title="0">{
                if err := m.deps.StopTestLog(); err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "testing: can't write %s: %s\n", *testlog, err)
                        os.Exit(2)
                }</span>
                <span class="cov0" title="0">if err := testlogFile.Close(); err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "testing: can't write %s: %s\n", *testlog, err)
                        os.Exit(2)
                }</span>
        }
        <span class="cov8" title="1">if *cpuProfile != "" </span><span class="cov0" title="0">{
                m.deps.StopCPUProfile() // flushes profile to disk
        }</span>
        <span class="cov8" title="1">if *traceFile != "" </span><span class="cov0" title="0">{
                trace.Stop() // flushes trace to disk
        }</span>
        <span class="cov8" title="1">if *memProfile != "" </span><span class="cov0" title="0">{
                f, err := os.Create(toOutputDir(*memProfile))
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "testing: %s\n", err)
                        os.Exit(2)
                }</span>
                <span class="cov0" title="0">runtime.GC() // materialize all statistics
                if err = m.deps.WriteProfileTo("allocs", f, 0); err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "testing: can't write %s: %s\n", *memProfile, err)
                        os.Exit(2)
                }</span>
                <span class="cov0" title="0">f.Close()</span>
        }
        <span class="cov8" title="1">if *blockProfile != "" &amp;&amp; *blockProfileRate &gt;= 0 </span><span class="cov0" title="0">{
                f, err := os.Create(toOutputDir(*blockProfile))
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "testing: %s\n", err)
                        os.Exit(2)
                }</span>
                <span class="cov0" title="0">if err = m.deps.WriteProfileTo("block", f, 0); err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "testing: can't write %s: %s\n", *blockProfile, err)
                        os.Exit(2)
                }</span>
                <span class="cov0" title="0">f.Close()</span>
        }
        <span class="cov8" title="1">if *mutexProfile != "" &amp;&amp; *mutexProfileFraction &gt;= 0 </span><span class="cov0" title="0">{
                f, err := os.Create(toOutputDir(*mutexProfile))
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "testing: %s\n", err)
                        os.Exit(2)
                }</span>
                <span class="cov0" title="0">if err = m.deps.WriteProfileTo("mutex", f, 0); err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "testing: can't write %s: %s\n", *mutexProfile, err)
                        os.Exit(2)
                }</span>
                <span class="cov0" title="0">f.Close()</span>
        }
        <span class="cov8" title="1">if cover.Mode != "" </span><span class="cov8" title="1">{
                coverReport()
        }</span>
}

// toOutputDir returns the file name relocated, if required, to outputDir.
// Simple implementation to avoid pulling in path/filepath.
func toOutputDir(path string) string <span class="cov8" title="1">{
        if *outputDir == "" || path == "" </span><span class="cov8" title="1">{
                return path
        }</span>
        // On Windows, it's clumsy, but we can be almost always correct
        // by just looking for a drive letter and a colon.
        // Absolute paths always have a drive letter (ignoring UNC).
        // Problem: if path == "C:A" and outputdir == "C:\Go" it's unclear
        // what to do, but even then path/filepath doesn't help.
        // TODO: Worth doing better? Probably not, because we're here only
        // under the management of go test.
        <span class="cov0" title="0">if runtime.GOOS == "windows" &amp;&amp; len(path) &gt;= 2 </span><span class="cov0" title="0">{
                letter, colon := path[0], path[1]
                if ('a' &lt;= letter &amp;&amp; letter &lt;= 'z' || 'A' &lt;= letter &amp;&amp; letter &lt;= 'Z') &amp;&amp; colon == ':' </span><span class="cov0" title="0">{
                        // If path starts with a drive letter we're stuck with it regardless.
                        return path
                }</span>
        }
        <span class="cov0" title="0">if os.IsPathSeparator(path[0]) </span><span class="cov0" title="0">{
                return path
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%s%c%s", *outputDir, os.PathSeparator, path)</span>
}

// startAlarm starts an alarm if requested.
func (m *M) startAlarm() time.Time <span class="cov8" title="1">{
        if *timeout &lt;= 0 </span><span class="cov0" title="0">{
                return time.Time{}
        }</span>

        <span class="cov8" title="1">deadline := time.Now().Add(*timeout)
        m.timer = time.AfterFunc(*timeout, func() </span><span class="cov0" title="0">{
                m.after()
                debug.SetTraceback("all")
                panic(fmt.Sprintf("test timed out after %v", *timeout))</span>
        })
        <span class="cov8" title="1">return deadline</span>
}

// stopAlarm turns off the alarm.
func (m *M) stopAlarm() <span class="cov8" title="1">{
        if *timeout &gt; 0 </span><span class="cov8" title="1">{
                m.timer.Stop()
        }</span>
}

func parseCpuList() <span class="cov8" title="1">{
        for _, val := range strings.Split(*cpuListStr, ",") </span><span class="cov8" title="1">{
                val = strings.TrimSpace(val)
                if val == "" </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov0" title="0">cpu, err := strconv.Atoi(val)
                if err != nil || cpu &lt;= 0 </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "testing: invalid value %q for -test.cpu\n", val)
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">cpuList = append(cpuList, cpu)</span>
        }
        <span class="cov8" title="1">if cpuList == nil </span><span class="cov8" title="1">{
                cpuList = append(cpuList, runtime.GOMAXPROCS(-1))
        }</span>
}

func shouldFailFast() bool <span class="cov8" title="1">{
        return *failFast &amp;&amp; atomic.LoadUint32(&amp;numFailed) &gt; 0
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
